<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="win32,win32 gui," />










<meta name="description" content="Win32 GUI基础图形化界面程序无法直接打印调信息，我们可以在代码中添加该命令，以实现通过控制台打印调试信息。 1#pragma comment( linker, &quot;&#x2F;subsystem:\&quot;console\&quot; &#x2F;entry:\&quot;WinMainCRTStartup\&quot;&quot;)    字符集计算机的字符集可分为单字节字符集（SBCS）、多字">
<meta property="og:type" content="article">
<meta property="og:title" content="win32 gui">
<meta property="og:url" content="https://walker-nie.github.io/win32/Win32%20GUI/index.html">
<meta property="og:site_name" content="walker&#39;s blog">
<meta property="og:description" content="Win32 GUI基础图形化界面程序无法直接打印调信息，我们可以在代码中添加该命令，以实现通过控制台打印调试信息。 1#pragma comment( linker, &quot;&#x2F;subsystem:\&quot;console\&quot; &#x2F;entry:\&quot;WinMainCRTStartup\&quot;&quot;)    字符集计算机的字符集可分为单字节字符集（SBCS）、多字">
<meta property="og:locale">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205135853136.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205140516041.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205141257581.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205141611094.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205141924724.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210203173243558.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210203175203387.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205145712158.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205145627048.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205165259257.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205170515568.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205181147646.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205181829335.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205181947797.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205182536411.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205182835222.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205183306873.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205175201185.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205172035983.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205172446181.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205163708885.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205171324188.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206160539492.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206160952767.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206165504126.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206171841196.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206172037981.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206173636661.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206173931232.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206185002796.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206185853437.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206190401384.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206181346479.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210206182549077.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207124251700.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207130743862.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207154934554.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207155316435.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207155900652.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207155944034.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207160328113.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207172356318.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207142037881.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207144326809.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207144946115.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207150305788.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210207170529343.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208125813842.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208125218931.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208131909438.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208143208786.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208144725003.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208150016180.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208150831772.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208182450925.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208153317296.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208160648494.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208163329040.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208170324650.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208172525566.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210208180425088.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210215142827558.png">
<meta property="og:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210215142728919.png">
<meta property="article:published_time" content="2022-01-03T05:14:26.000Z">
<meta property="article:modified_time" content="2022-01-03T05:39:58.948Z">
<meta property="article:author" content="walker">
<meta property="article:tag" content="win32">
<meta property="article:tag" content="win32 gui">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://walker-nie.github.io/win32/Win32%20GUI/image-20210205135853136.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://walker-nie.github.io/win32/Win32 GUI/"/>





  <title>win32 gui | walker's blog</title>
  








<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">walker's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://walker-nie.github.io/win32/Win32%20GUI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="walker's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">win32 gui</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-01-03T13:14:26+08:00">
                2022-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/win32/" itemprop="url" rel="index">
                    <span itemprop="name">win32</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,922 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Win32-GUI"><a href="#Win32-GUI" class="headerlink" title="Win32 GUI"></a>Win32 GUI</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>图形化界面程序无法直接打印调信息，我们可以在代码中添加该命令，以实现通过控制台打印调试信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">&quot;/subsystem:\&quot;console\&quot; /entry:\&quot;WinMainCRTStartup\&quot;&quot;</span>)</span></span><br></pre></td></tr></table></figure>



<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>计算机的字符集可分为单字节字符集（<code>SBCS</code>）、多字节字符集（<code>MBCS</code>）、宽字符集（<code>unicode</code>） 。</p>
<ul>
<li><p><strong>单字节字符集（Single-Byte Character System）</strong>：所有字符长度都为1字节，字符串以 <code>0x00</code> 为结束符，数据类型为 <code>char</code> 类型。常见的字符集有：<code>ASCII</code> 码和拓展 <code>ASCII</code> 码。</p>
<p><img src="/win32/Win32%20GUI/image-20210205135853136.png" alt="image-20210205135853136"></p>
</li>
</ul>
<ul>
<li><p><strong>多字节字符集（Multi-Byte Character System / ANSI）</strong>：英文字符用一个字节表示，利用连续多个拓展 <code>ASCII</code> 码来表示一个其他语言文字。<code>MBCS</code> 字符由 <code>0x00</code> 结尾，数据类型是 <code>char</code> 类型。</p>
<p>不同的国家和地区制定了不同的标准，由此产生了 <code>GB2312</code>、<code>GBK</code>、<code>GB18030</code>、<code>Big5</code>、<code>Shift_JIS</code> 等各自的编码标准。这些使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 <code>ANSI</code> 编码。在简体中文 <code>Windows</code> 操作系统中，<code>ANSI</code> 编码代表 <code>GB2312</code> 编码；在繁体中文 <code>Windows</code> 操作系统中，<code>ANSI</code> 编码代表 <code>Big5</code> ；在日文 <code>Windows</code> 操作系统中，<code>ANSI</code>  编码代表  <code>JIS</code>  编码。</p>
<p><img src="/win32/Win32%20GUI/image-20210205140516041.png" alt="image-20210205140516041"></p>
</li>
</ul>
<ul>
<li><strong><code>Unicode</code> 字符集</strong>：通用多八位编码字符集，是国际标准化组织 <code>ISO</code> 为了解决传统的字符编码方案的局限而产生的。它为每种语言中的每个字符设定了统一并且唯一的码值，以满足跨语言的要求。<code>unicode</code> 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。</li>
</ul>
<ul>
<li><p><strong><code>UTF</code> 编码（<code>Unicode Transformation Format</code>）</strong>：<code>UTF</code> 通过对 <code>Unicode</code> 码值进行对应规则转换后，将编码写入内存/文件中。</p>
<p><img src="/win32/Win32%20GUI/image-20210205141257581.png" alt="image-20210205141257581"></p>
<p>​                <img src="/win32/Win32%20GUI/image-20210205141611094.png" alt="image-20210205141611094"></p>
</li>
</ul>
<p>下图为记事本的文件保存编码格式。（ <code>Windows</code> 默认使用的字符集是 <code>UTF-16</code> 字符集）</p>
<img src="/win32/Win32%20GUI/image-20210205141924724.png" alt="image-20210205141924724" style="zoom:80%;" align="left">



<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><code>Win32 API</code> 数据类型的定义所在头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minwindef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;basetsd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WTypebase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Winnt.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<p><em><strong>常用数据类型</strong></em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>原定义</th>
</tr>
</thead>
<tbody><tr>
<td>CONST</td>
<td>const</td>
</tr>
<tr>
<td>CALLBACK</td>
<td>_stdcall</td>
</tr>
<tr>
<td>WINAPI</td>
<td>_stdcall</td>
</tr>
<tr>
<td>VOID</td>
<td>VOID</td>
</tr>
<tr>
<td>TCHAR（通用符号）</td>
<td>Unicode：WCHAR；<br>ANSI：char</td>
</tr>
<tr>
<td>TEXT（通用符号）</td>
<td>Unicode：<code>Unicode</code> 字符串；<br>ANSI：<code>ANSI</code> 字符串</td>
</tr>
<tr>
<td><code>API</code> 函数名</td>
<td>W/A</td>
</tr>
<tr>
<td>LPCSTR/LPSTR/PCSTR</td>
<td>指向ANSI字符串类型指针</td>
</tr>
<tr>
<td>LPCWSTR/LPWSTR/PCWSTR</td>
<td>指向Unicode字符串类型</td>
</tr>
<tr>
<td>LPCTSTR/LPTSTR/PCTSTR</td>
<td>指向一8位或16位字符串类型指针</td>
</tr>
<tr>
<td>LPVOID</td>
<td>指向一个未指定类型的32位指针</td>
</tr>
<tr>
<td>LPDWORD</td>
<td>指向一个DWORD型指针</td>
</tr>
</tbody></table>
<p><em><strong>宽字符与多字节字符</strong></em></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>相关函数</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>多字节字符，每个 <code>char</code> 占1字节。<br>表示英文字符时是1个字节；表示中文时是2字节</td>
<td>字符串长度：<code>strlen()</code><br>字符串复制：<code>strcpy()</code><br>输出：<code>printf()</code></td>
</tr>
<tr>
<td>wchar_t</td>
<td>宽字符，占2字节。用常量字符给 <code>wchar_t</code> 类型的变量赋值时，前需加 <code>L</code> 。<br>如：<code>wchar_t str[] = &#123;L”walker!”&#125;;</code></td>
<td>字符串长度：<code>wcslen()</code><br>字符串复制：<code>wcscpy</code><br>输出：<code>wprintf()</code></td>
</tr>
</tbody></table>
<p>如以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Locale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_wsetlocale(LC_ALL, <span class="string">L&quot;chs&quot;</span>);</span><br><span class="line">	<span class="keyword">wchar_t</span> *str = (<span class="keyword">wchar_t</span> *)<span class="string">L&quot;walker哈哈&quot;</span>;</span><br><span class="line">	wprintf(<span class="string">L&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="函数入口"><a href="#函数入口" class="headerlink" title="函数入口"></a>函数入口</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span> <span class="params">(			<span class="comment">// WINAPI, 即_stdcall, 标准调用约定</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hInstance,		<span class="comment">//应用程序当前实例的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    HINSTANCE hPrevInstance,	<span class="comment">//应用程序的先前实例的句柄。同一个程序打开两次，出现两个窗口第一次打开的窗口就是先前实例的窗口。对于一个32位程序,该参数总为NULL。</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPSTR IpCmdLine, 			<span class="comment">//命令行的字符串的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nShowCmd 				<span class="comment">//窗口显示方式, 默认为SW_SHOWDEFAULT; 如窗口最大化、后台运行等</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;Hello World!&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210203173243558.png" alt="image-20210203173243558" style="zoom:80%;" align="left">



<h4 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">&quot;/subsystem:\&quot;console\&quot; /entry:\&quot;WinMainCRTStartup\&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>   WINAPI   <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLind, <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//程序实例句柄</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, hInstance, hPrevInstance);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//程序命令行字符串</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;cmd info is %s\n&quot;</span>, lpCmdLind);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运用程序窗口的初始显示方式</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, nShowCmd);</span><br><span class="line"></span><br><span class="line">	MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;over!&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210203175203387.png" alt="image-20210203175203387"></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>窗口类 <code>WNDCLASS</code> 是 <code>Windows</code> 中用于创建窗口的模板。每-个窗口类都有一个窗口过程(WndProc)，负责处理发送该类窗口的所有消息。一个应用程序在创建某个类型的窗口前，必须首先注册该“窗口类”(注意, 这里不是C+ +类的类)。窗口类有三种:系统窗口类中一部分是系统内部使用的,而另一部分是可以供系统所有进程使用的，这些窗口类就<br>是基本的控件窗口类。<br>应用程序全局窗口类，就是注册窗口类时以CS_ GLOBALCLASS标志注册的窗口类，这个窗口类在这<br>个进程中，所有模块都可以使用。模块一般是dI模块。 我们知道的程序的皮肤库，很多都是以这种<br>形式实现的，dlI中注册的应用程序全局窗口类，我们程序就可以直接使用这些漂亮的皮肤库提供的<br>控件了。<br>应用程序局部窗口类则是没有CS_ GLOBALCLASS标志注册的窗口类,这个窗口类只在模块范围内使<br>用。我们的EXE如果加载了其他的dII模块，此时EXE的主线程注册的应用程序局部窗口类对于d来<br>说，是看不见的，也就不能使用这个局部窗口类来创建窗口。</p>
<h2 id="GUI-API"><a href="#GUI-API" class="headerlink" title="GUI API"></a>GUI API</h2><p><code>Win32 API </code> 的分类如下表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>dll</th>
</tr>
</thead>
<tbody><tr>
<td>基础服务（Base Services）</td>
<td>内核函数，提供对Windows系统基础资源的访问接口。如文件系统、内存管理、外部设备、进程(process) 、线程(thread) 以及访问注册表和错误处理机制。</td>
<td>kernel32.dlI</td>
</tr>
<tr>
<td>图形设备接口（GDI）</td>
<td>输出图形内容到显示器、打印机以及其他外部输出设备。</td>
<td>gdi32.dll</td>
</tr>
<tr>
<td>图形化用户界面（GUI）</td>
<td>Windows用户界面相关应用程序接口，提供的功能有创建和管理屏幕和大多数基本控件（control）。如创建窗口、滚动条、消息、菜单、光标、计时器和发送消息以及其他与GUI有关的功能。</td>
<td>user32.dll</td>
</tr>
<tr>
<td>通用控件链接库（Common Control Library）</td>
<td>为应用程序提供接口来访问操作系统提供的一些高级控件。如：状态栏（status bar）、进度条（progress bars）、工具栏（toolbar) 和标签（tab)。</td>
<td>comctl32.dlI</td>
</tr>
<tr>
<td>Windows外壳（Windows Shell）</td>
<td>作为Windows API的组成部分，不仅允许应用程序访问Windows外壳提供的功能，还对之有所改进和增强。</td>
<td>shell32.dII</td>
</tr>
<tr>
<td>网络服务（Network Services）</td>
<td>为访问操作系统提供的多种网络功能提供接口。它包括NetBIOS、Winsock、 NetDDE及RPC等。</td>
<td>ws2_ 32.dIl</td>
</tr>
</tbody></table>
<h3 id="A-W"><a href="#A-W" class="headerlink" title="A/W"></a>A/W</h3><p><code>Win32 API</code> 中带字符串的 <code>API</code> 一般都有两个版本，例如 <code>CreateFileA</code> 和 <code>CreateFileW</code> 。当然也有例外，例如 <code>GetProcAddress</code> 函数。<code>A</code> 代表 <code>ANSI</code> 编码,，<code>W</code> 代表 <code>Unicode</code> 字符集。<code>Windows</code> 中的 <code>Unicode</code> 字符一般指 <code>UCS2</code> 的 <code>UTF16-LE</code> 编码。</p>
<p>当项目的字符集为 <code>Unicode</code> 字符集时，使用的是 <code>Unicode</code> 类型的 <code>API</code> 函数。</p>
<p><img src="/win32/Win32%20GUI/image-20210205145712158.png" alt="image-20210205145712158"></p>
<img src="/win32/Win32%20GUI/image-20210205145627048.png" alt="image-20210205145627048" style="zoom:80%;" align="left">



<h3 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h3><table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SetWindowText</td>
<td>设置窗口标题，设置静态文本内容</td>
</tr>
<tr>
<td>GetWindowText</td>
<td>获取窗口内容</td>
</tr>
<tr>
<td>UpdateWindow</td>
<td>更新窗口客户区</td>
</tr>
<tr>
<td>GetModuleHandle</td>
<td>获取当前进程的实例句柄</td>
</tr>
<tr>
<td>GetDlgItemText</td>
<td>获取对话框内容</td>
</tr>
<tr>
<td>GetDesktopWindow</td>
<td>获取桌面进程的句柄</td>
</tr>
<tr>
<td>GetDlgItem</td>
<td>获取指定对话框的控件句柄</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>GetOpenFileName</td>
<td>通过系统文件管理对话框选择文件</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h2><p><strong><code>Windows</code> 应用程序都是消息（事件）驱动的，任何一个窗口都能够接收消息，并对该消息做出相应的处理。<code>Windows</code> 系统和应用程序均可产生消息，比如当点击、移动鼠标或者敲击键盘，系统捕捉到事件时，便会产生一个消息。</strong>应用程序引起系统改变也会导致系统产生消息，比如一个应用程序改变了窗口的大小。</p>
<p><em><strong>消息处理过程如下：</strong></em></p>
<img src="/win32/Win32%20GUI/image-20210205165259257.png" alt="image-20210205165259257" style="zoom:80%;" align="left">

<ol start="0">
<li><p>每个线程可以有多个窗口对象，当窗口对象创建成功，对应线程对象就存在消息队列。</p>
</li>
<li><p>当用户产生动作时，操作系统将消息打包成一个类，其中包含消息的句柄、操作信息。</p>
</li>
<li><p>通过设备驱动程序，将消息存放在 <code>Windows</code> 的系统消息队列中。</p>
</li>
<li><p>操作系统将系统队列中的消息取出，依据消息句柄将消息投掷于其对应的窗口对象所属的线程消息队列中。</p>
</li>
<li><p>应用程序的消息循环把消息取出后将消息传递给窗口过程。</p>
</li>
<li><p>通过 <code>GetMessage</code>  函数将线程消息队列中的消息取出。</p>
</li>
<li><p>调用 <code>DispatchMessage</code> 函数获取当前窗口句柄进入内核，找到对应的窗口消息处理函数。</p>
</li>
<li><p>内核程序调用消息处理函数处理消息。</p>
</li>
</ol>
<h3 id="MSG"><a href="#MSG" class="headerlink" title="MSG"></a>MSG</h3><p>在进行消息传递时，操作系统会将消息封装在 <code>MSG</code> 结构体中，并将 <code>MSG</code> 存储在系统消息队列中。</p>
<img src="/win32/Win32%20GUI/image-20210205170515568.png" alt="image-20210205170515568" style="zoom: 50%;" align="left">



<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>在 <code>Windows</code> 中，消息类型可分为：标准消息、命令消息、通知消息。</p>
<p>标准消息：所有以 <code>WM_</code>  开头的消息，<code>WM_COMMAND</code> 除外。</p>
<p>命令消息：来自菜单、工具栏或快捷键的消息，以 <code>WM_COMMAND</code> 呈现。</p>
<p>通知消息：由空间产生的消息，如：按钮点击列表框的选择等。作用是向父窗口通知事件的发生，以 <code>WM_COMMANF</code> 或 <code>WM_NOTIFY</code> 的形式呈现。<code>LOWORD(wParam)</code> 是控件ID，<code>HIWORD(wParam)</code> 是 <code>notification code</code> 。</p>
<hr>
<h5 id="WM-COMMAND"><a href="#WM-COMMAND" class="headerlink" title="WM_COMMAND"></a>WM_COMMAND</h5><p><img src="/win32/Win32%20GUI/image-20210205181147646.png" alt="image-20210205181147646"></p>
<h5 id="VM-NOTIFY"><a href="#VM-NOTIFY" class="headerlink" title="VM_NOTIFY"></a>VM_NOTIFY</h5><p><code>WM_COMMAND</code> 可携带的信息较少，<code>WM_NOTIFY</code> 比 <code>WM_COMMAND</code> 功能更强大，可以存储一些额外的信息。</p>
<p><code>Edit,Button,ListBox</code> 等发送 <code>WM_COMMAND</code> 消息，而 <code>ListView,Toolbar,Tree</code> 等控件发送 <code>WM_NOTIFY</code> 消息，因为需要提供的信息更多。</p>
<p><img src="/win32/Win32%20GUI/image-20210205181829335.png" alt="image-20210205181829335"></p>
<p>我们将所有附加信息都存放在<code>NMHDR(Notify Message Handler)</code> 的一个公共结构体中，该结构体指针通过 <code>LPARAM</code> 指向。</p>
<p><code>NMHDR</code> 的结构如下:</p>
<img src="/win32/Win32%20GUI/image-20210205181947797.png" alt="image-20210205181947797" style="zoom:50%;" align="left">



<p>当某控件需要更多的附加信息时，我们就可以根据该控件的特点定义结构体，但要求第一个字段一定是 <code>NMHDR</code> 。</p>
<p>如我们想要知道 <code>ListView</code> 选中的行和列，那么就可以定义如下：</p>
<img src="/win32/Win32%20GUI/image-20210205182536411.png" alt="image-20210205182536411" style="zoom:50%;" align="left">

<p>以此，我们通过自定义结构体实现对附加信息的扩充。</p>
<p>一些 <code>Notification Code</code> 对所有新的 <code>Windows</code> 控件来说是通用的。</p>
<img src="/win32/Win32%20GUI/image-20210205182835222.png" alt="image-20210205182835222" style="zoom:67%;" align="left">



<h5 id="自定义消息"><a href="#自定义消息" class="headerlink" title="自定义消息"></a>自定义消息</h5><p>我们可以使用 <code>WM_USER</code>  创建自定义消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_USER 0x400+x</span></span><br></pre></td></tr></table></figure>



<p><em>消息 <code>ID</code> 范围</em></p>
<img src="/win32/Win32%20GUI/image-20210205183306873.png" alt="image-20210205183306873" style="zoom: 80%;" align="left">



<h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><h5 id="SendMessage"><a href="#SendMessage" class="headerlink" title="SendMessage"></a>SendMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,		<span class="comment">// 接收消息的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,		<span class="comment">// 消息ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,	<span class="comment">// 附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam		<span class="comment">// 附加消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将指定的消息发送到一个或多个窗口并阻塞，直到窗口过程已经处理了该消息。</p>
<p>要发送消息并立即返回，可使用 <code>SendMessageCallback</code> 或 <code>SendNotifyMessage</code> 函数。要将消息发布到线程的消息队列中并立即返回，可使用 <code>PostMessage</code> 或 <code>PostThreadMessage</code> 函数。</p>
<h5 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND   hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,</span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将消息存放在与当前线程关联的消息队列中，并返回消息，而无需等待线程处理消息。</p>
<h5 id="PostThreadMessage"><a href="#PostThreadMessage" class="headerlink" title="PostThreadMessage"></a>PostThreadMessage</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostThreadMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD  idThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  UINT   Msg,</span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将消息发布到指定线程（可以是不同线程）的消息队列，直接返回而无需等待线程处理消息。</p>
<p><img src="/win32/Win32%20GUI/image-20210205175201185.png" alt="image-20210205175201185"></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><code>Windows</code> 中有一个系统消息队列，以及分别为每个 <code>GUI</code> 线程维护一个各自的线程消息队列（应用程序消息队列）。为了避免非 <code>GUI</code> 线程创建线程消息队列的开销，所有线程创建初始化时，均不创建消息队列。只有当线程第一次调用 <code>GDI</code> 函数（画图函数，即创建界面，位于 <code>User32.dll</code> 和 <code>GDI32.dll</code> 中）时， 系统才会为线程创建消息队列，所以那些非 <code>GUl</code> 线程是没有消息队列的。</p>
<img src="/win32/Win32%20GUI/image-20210205172035983.png" alt="image-20210205172035983" style="zoom: 50%;" align="left">



<p><strong>线程与消息队列</strong></p>
<p>在一个线程中可以产生多个窗口，每个窗口可共用一个线程消息队列，所以某个窗口产生的消息，都是先由创建这个窗口的线程处理的。窗口在任何线程中都可以创建，但消息循环必须要和创建窗口在同一线程，否则窗口将无法从 <code>DispatchMessage</code> 函数中获取任何消息。</p>
<img src="/win32/Win32%20GUI/image-20210205172446181.png" alt="image-20210205172446181" style="zoom:50%;" align="left">





<h3 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h3><p><code>UI</code> 线程启动一个消息循环，每次从本线程所对应的消息队列中取出一条消息，然后根据消息所包容的信息，将其转发给特定的窗体对象，此窗体对象所对应的窗体过程（消息处理函数）被调用以处理这些消息。</p>
<img src="/win32/Win32%20GUI/image-20210205163708885.png" alt="image-20210205163708885" style="zoom:80%;" align="left">



<p><strong>消息循环的结束</strong></p>
<p>当实现程序结束时，应用程序可以调用 <code>PostQuitMessage</code> 函数发送 <code>WM_ QUIT</code> 消息，结束消息循环。<code>PostQuitMessage</code> 函数投递一 个 <code>WM_ QUIT</code> 消息到线程消息队列并且立即返回，以结束消息循环，并终结程序 <code>WM_CLOSE</code>。该函数简通常用来响应 <code>WM_ DESTROY</code> 消息。</p>
<p><img src="/win32/Win32%20GUI/image-20210205171324188.png" alt="image-20210205171324188"></p>
<h3 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h3><p>每个窗口都有窗口过程来处理窗口接收到的消息。窗口过程是一个回调函数， 它是由 <code>Windows</code> 自动调用的。</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="WM-NCCREATE"><a href="#WM-NCCREATE" class="headerlink" title="WM_NCCREATE"></a>WM_NCCREATE</h4><p>使用 <code>CreateWindow</code> 函数创建窗口时，<code>CreateWindow</code> 先直接发送 <code>WM_NCCREATE</code> 消息（先于 <code>WM_CREATE</code> 消息）给窗口过程函数，NC，即 <code>non-client</code> 区域，包括标题栏、窗口边框、最大、最小按钮、滚动条等。如果应用程序处理此消息，则应该返回 <code>TRUE</code> 以继续创建窗口，如果应用程序返回<code>FALSE</code> ，则 <code>CreateWindow</code> 或 <code>CreateWindowEx</code> 函数将返回 <code>NULL</code> 句柄。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM_NCCREATE	0x0081</span></span><br></pre></td></tr></table></figure>

<p>注：<code>wParam</code> 未使用；<code>lParam</code>  为指向 <code>CREATESTRUCT</code> 结构的指针，其中包含有关正在创建的窗口的信息。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCCREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;nccreate...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hwnd, uMsg, wParam, lParam);</span><br><span class="line">    <span class="comment">//CREATESTRUCT* pCreateStruct = (CREATESTRUCT*)lParam;</span></span><br><span class="line">    <span class="comment">//return TRUE;		</span></span><br><span class="line">    <span class="comment">/* 自己处理后, WindowsText 存在问题 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，<code>WM_NCCREATE</code> 的消息处理确实是优先于 <code>WM_CREATE</code> 。</p>
<img src="/win32/Win32%20GUI/image-20210206160539492.png" alt="image-20210206160539492" style="zoom:80%;" align="left">



<h4 id="WM-CREATE"><a href="#WM-CREATE" class="headerlink" title="WM_CREATE"></a>WM_CREATE</h4><p>发送完 <code>WM_ NCCREATE</code> 后，<code>CreateWindow</code> 函数在窗口创建成功并且在返回之前发送 <code>WM_CREATE</code> 消息给窗口过程函数，窗口过程函数会在创建窗口后但在窗口变为可见之前接收到此消息（可以在此时机初始化滚动条，创建子窗口、控件等等)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0001</span></span><br></pre></td></tr></table></figure>



<p>注：<code>wParam</code> 未使用；<code>lParam</code> 为指向 <code>CREATESTRUCT</code> 结构的指针，其中包含有关正在创建的窗口的信息。</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>窗口关闭流程如下：</p>
<img src="/win32/Win32%20GUI/image-20210206160952767.png" alt="image-20210206160952767" align="left">



<img src="/win32/Win32%20GUI/image-20210206165504126.png" alt="image-20210206165504126" style="zoom:80%;" align="left">



<h4 id="WM-CLOSE"><a href="#WM-CLOSE" class="headerlink" title="WM_CLOSE"></a>WM_CLOSE</h4><p>当我们点击窗口的关闭按钮时，会产生 <code>WM_CLOSE</code> 消息，而操作系统接收此消息，操作系统通过调用 <code>DestroyWindow</code> 和 <code>PostQuitMessage</code> 函数实现关闭并销毁窗口，结束消息循环。 （<code>WM_CLOSE</code> 的作用就是将窗口从屏幕上移除，使其不可见）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0010</span></span><br></pre></td></tr></table></figure>



<p><code>DestroyWindow</code> 函数：销毁指定的窗口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DestroyWindow</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hWnd<span class="comment">//要销毁的窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>该函数将 <code>WM_ DESTROY</code> 和 <code>WM_ NCDESTROY</code> 消息发送到窗口以停用它并从中移除键盘焦点。该功能还销毁窗口的菜单，刷新线程消息队列，破坏定时器，删除剪贴板所有权，并打破剪贴板查看器链(如果窗口位于查看器链的顶部)。如果指定的窗口是父窗口或所有者窗口，则 <code>DestroyWindow</code> 会在销毁父窗口或所有者窗口时自动销毁关联的子窗口或拥有的窗口。该函数首先销毁子窗口或拥有的窗口，然后销毁父窗口或所有者窗口。<code>DestroyWindow</code> 也破坏 <code>CreateDialog</code> 函数创建的无模式对话框。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close windows...\n&quot;</span>);</span><br><span class="line">    DestroyWindow(hwnd);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);	// 有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：该消息可直接返回给 <code>DefWindowProc </code> 处理；若是手动处理，必须手动调用 <code>DestroyWindow</code> 函数，以实现关闭窗口，否则窗口将无法关闭！</strong></p>
<h4 id="WM-DESTROY"><a href="#WM-DESTROY" class="headerlink" title="WM_DESTROY"></a>WM_DESTROY</h4><p>窗口从屏幕上移除后，<code>WM_DESTROY</code> 被发送到正在销毁的窗口的窗口过程。如果一个应用程序处理这个消息，它应该返回零。此时可用于释放与窗口关联的已分配内存对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM CREATE 0x0002</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">&#123;</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;destroy windows...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);	// 无效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：<code>WM_DESTROY</code> 消息必须手动处理，而且必须手动调用 <code>PostQuitMessage</code> 以结束消息循环，将消息返回给 <code>DefWindowProc</code>  无效。</strong></p>
<h4 id="WM-NCDESTROY"><a href="#WM-NCDESTROY" class="headerlink" title="WM_NCDESTROY"></a>WM_NCDESTROY</h4><p>通知窗口其非客户区域（边框、系统菜单栏）正在销毁。如果一个应用程序处理这个消息，它应该返回零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCDESTROY:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ncdestroy windows...\n&quot;</span>);</span><br><span class="line">    <span class="comment">//return DefWindowProc(hwnd, uMsg, wParam, lParam);		// 有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：<code>WM_NCDESTROY</code> 消息，无需手动处理，可直接返回给 <code>DefWindowProc</code> 处理。该消息无需做任何处理，也可直接返回。</strong></p>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><h4 id="WM-PAINT"><a href="#WM-PAINT" class="headerlink" title="WM_PAINT"></a>WM_PAINT</h4><p><code>WM_PAINT</code> 消息的触发时机：</p>
<ol>
<li>程序启动时，<code>UpdateWindow</code> 函数发送一个 <code>WM_PAINT</code> 消息来更新指定窗口的客户区。</li>
<li>用鼠标调整窗口的大小，时会连续触发。</li>
<li>最小化时不会触发 <code>WM_ PAINT</code> 消息，但是从最小化还原时会进行触发。</li>
<li>最大化时会触发 <code>WM_PAINT</code> 消息。</li>
<li>当向屏幕外拖动窗口时，不会触发 <code>WM_PAINT</code> 消息，但是拉回到屏幕内时会不断的触发 <code>WM_ PAINT</code> 消息。</li>
<li>使用 <code>InvalidateRect</code> 函数时会触发 <code>WM_PAINT</code> 消息。</li>
<li>移动或者覆盖窗口，不会产生 <code>WM_PAINT</code> 消息 ，因为窗口的客户区大小并未改变!</li>
</ol>
<p><strong><code>WM_PAINT</code> 消息的处理</strong></p>
<p>如果应用程序在窗口过程中用如下方法处理 <code>WM_ PAINT</code> 消息，那么将导致不停的发送消息！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM PAINT:</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/win32/Win32%20GUI/image-20210206171841196.png" alt="image-20210206171841196" style="zoom: 80%;" align="left">



<p>如果当前窗口用户区的某一部分变为无效，则 <code>Windows</code> 会将一 个 <code>WM_PAINT</code> 消息放到消息队列中，如果不调用 <code>BeginPaint</code> 和<code>EndPaint</code> 函数处理，(同时也不调用 <code>ValidateRect</code> 函数)，则该无效区域不会变为有效，于是 <code>Windows</code> 将会持续发送 <code>WM_PAINT</code> 消息，直到消息被处理（使用户区域有效化）。默认消息处理函数 <code>DefWindowProc</code> 可以处理 <code>WM_PAINT</code> 消息。</p>
<img src="/win32/Win32%20GUI/image-20210206172037981.png" alt="image-20210206172037981" style="zoom:80%;" align="left">



<p>当我们移动、操作窗口时，就会产生 <code>WM_PAINT</code> 消息。</p>
<p><strong>窗口有效化</strong></p>
<p>我们可以使用 <code>BeginPaint</code> 函数，使得窗口有效化，此时 <code>windows</code> 将不会重复发送 <code>WM_PAINT</code> 消息，直到窗口因改变大小或移动而造成窗口再次无效化为止。（当窗口无效化时，将会一直产生 <code>WM_PAINT</code> 消息。）</p>
<p>需要注意的是，当使用 <code>BeginPaint</code> 函数时，必须调用 <code>EndPaint</code> 函数结束窗口有效化。</p>
<p><strong>PAINTSTRUCT结构</strong></p>
<p>每个窗口都有一个 <code>PAINTSTRUCT</code> 结构来记录一些绘制信息，<code>PAINTSTRUCT</code> 结构保存了应用程序拥有的窗口的客户区域的属性。</p>
<img src="/win32/Win32%20GUI/image-20210206173636661.png" alt="image-20210206173636661" style="zoom: 50%;" align="left">



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_PAINT:</span><br><span class="line">&#123;</span><br><span class="line">    PAINTSTRUCT ps;</span><br><span class="line">    HDC hdc = BeginPaint(hwnd, &amp;ps);	<span class="comment">// 使无效区域有效化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> UINT i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print windows %d\n&quot;</span>, i++);</span><br><span class="line">    EndPaint(hwnd, &amp;ps);</span><br><span class="line">    <span class="comment">// return DefWindowProc(hwnd, uMsg, wParam, lParam);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，当调用 <code>BeginPaint()</code> 函数使得窗口有效化时，只产生了一个 <code>WM_PAINT</code> 消息，而系统消处理函数效果相同。</p>
<img src="/win32/Win32%20GUI/image-20210206173931232.png" alt="image-20210206173931232" style="zoom:80%;" align="left">



<h4 id="WM-NCPAINT"><a href="#WM-NCPAINT" class="headerlink" title="WM_NCPAINT"></a>WM_NCPAINT</h4><p>当窗口客户区以外的部分（如窗口标题栏、菜单栏等）需要重新绘制时，系统向程序发出 <code>WM_NCPAINT</code> 消息。因标准窗口的客户区以外部分为窗口必需部分，因而该消息将默认被发送到 <code>DefWindowProc</code> 函数进行默认处理。我们可通过截获该消息来实现窗口框架自定义绘制。<code>wParam</code> ，即窗口更新区域的句柄，更新区域被剪裁到窗口框架中；<code>lParam</code> 参数未使用。</p>
<img src="/win32/Win32%20GUI/image-20210206185002796.png" alt="image-20210206185002796" style="zoom:80%;" align="left">



<p>当对该消息不做任何处理直接返回时，标题栏没有任何显示。当我们对该消息进行处理时，接可以实现自定义标题栏。</p>
<p><img src="/win32/Win32%20GUI/image-20210206185853437.png" alt="image-20210206185853437"></p>
<p><strong>自定义标题栏</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_NCPAINT:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ncprint...\n&quot;</span>);</span><br><span class="line">    HDC  hdc = GetWindowDC(hwnd);</span><br><span class="line">    RECT  r;</span><br><span class="line">    r.left = <span class="number">0</span>;</span><br><span class="line">    r.top = <span class="number">0</span>;</span><br><span class="line">    r.right = <span class="number">300</span>;</span><br><span class="line">    r.bottom = <span class="number">30</span>;</span><br><span class="line">    HBRUSH  brh = CreateSolidBrush(RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    FillRect(hdc, &amp;r, brh);</span><br><span class="line">    SetBkMode(hdc, TRANSPARENT);</span><br><span class="line">    TextOutA(hdc, <span class="number">5</span>, <span class="number">5</span>, <span class="string">&quot;自定义窗口标题&quot;</span>, <span class="number">14</span>);<span class="comment">//最后一个参数为字符串长度</span></span><br><span class="line">    DeleteObject(brh);</span><br><span class="line">    ReleaseDC(hwnd, hdc);</span><br><span class="line">    <span class="keyword">return</span>  TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210206190401384.png" alt="image-20210206190401384"></p>
<h4 id="WM-ERASEBKGND"><a href="#WM-ERASEBKGND" class="headerlink" title="WM_ERASEBKGND"></a>WM_ERASEBKGND</h4><p>当窗口的移动，窗口的大小的改变时，必须在擦除窗口背景时发送 <code>WM_ERASEBKGND</code> 消息，以准备用于重新绘制无效部分的窗口。<code>Windows</code> 会给窗口先发出一次或者几次的 <code>WM_ERASEBKGND</code> 消息，紧接着是 <code>WM_PAINT</code> 消息。 </p>
<p>当窗口无效时，<code>DefWindowProc</code> 函数默认通过使用 <code>WNDCLASS</code> 结构中指定的 <code>hbrBackground</code> 背景画笔擦除背景。如果 <code>hbrBackground</code> 为 <code>NULL</code> ，则应用程序应处理 <code>WM_ERASEBKGND</code> 消息并清除背景。</p>
<p>如果应用程序处理消息并擦除背景，应用程序应返回非零值以响应 <code>WM_ERASEBKGND</code> ，这表明不需要进一步擦除。如果应用程序返回零，窗口将保持标记为需要擦除（通常，这表示 <code>BeginPaint</code> 中获取的 <code>PAINTSTRUCT</code> 结构的 <code>fErase</code> 成员将为 <code>TRUE</code>）。</p>
<p>其中，<code>wParam</code> 表示设备上下文句柄，<code>IParam</code> 未使用。</p>
<p><img src="/win32/Win32%20GUI/image-20210206181346479.png" alt="image-20210206181346479"></p>
<p><strong>更新窗口客户区</strong></p>
<p><code>UpdateWindow</code> ：</p>
<p><code>InvalidateRect</code> ：添加一个矩形到指定窗口的更新区域(必须重绘的窗口客户区域部分)。</p>
<p><code>RedrawWindow</code> ：更新窗口的客户区指定的矩形或区域。</p>
<img src="/win32/Win32%20GUI/image-20210206182549077.png" alt="image-20210206182549077" style="zoom: 67%;" align="left">



<p><em><strong>为什么操作系统在应用消息队列为空时才发送 <code>WM_PAINT</code> 消息呢?</strong></em></p>
<p>这是因为系统把在窗口中的绘制操作当作一种低优先级的操作，于是尽可能地推后做。不过这样也有利于提高绘制的效率：两个 <code>WM_PAINT</code> 消息之间通过 <code>InvalidateRect</code> 和 <code>InvaliateRgn</code> 使之失效的区域就会被累加起来，然后在一个 <code>WM_PAINT</code> 消息中一次得到更新，不仅能避免多次重复地更新同一区域，也优化了应用的更新操作。像这种通过 <code>InvalidateRect</code> 和 <code>InvalidateRgn</code> 来使窗口区域无效，依赖于系统。</p>
<p>在合适的时机发送 <code>WM_PAINT</code> 消息的机制实际上是一种异步工作方式，也就是说，在无效化窗口区域和发送 <code>WM_PAINT</code> 消息之间是有延迟的。有时候这种延迟并不是我们希望的，可以使用 <code>Windows GDI</code> 为我们提供的更方便和强大的函数：<code>UpdateWindow</code> 和 <code>RedrawWindow</code>。<code>UpdateWindow</code> 会检查窗口的 <code>Update Region</code>，当其不为空时才发送 <code>WM_PAINT</code> 消息;。<code>RedrawWindow</code> 则给我们更多的控制：是否重画非客户区和背景，是否总是发送 <code>WM_PAINT</code> 消息而不管 <code>Update Region</code> 是否为空等。</p>
<h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p><strong>鼠标相关消息</strong></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WM_LBUTTONDOWN</td>
<td>鼠标左键按下</td>
</tr>
<tr>
<td>WM_LBUTTONUP</td>
<td>鼠标左键抬起</td>
</tr>
<tr>
<td>WM_RBUTTONDOWN</td>
<td>鼠标右键按下</td>
</tr>
<tr>
<td>WM_RBUTTONUP</td>
<td>鼠标右键抬起</td>
</tr>
<tr>
<td>WM_MOUSEMOVE</td>
<td>鼠标移动消息</td>
</tr>
<tr>
<td>WM_LBUTTONDBLCLK</td>
<td>鼠标左键双击</td>
</tr>
<tr>
<td>WM_RBUTTONDBLCLK</td>
<td>鼠标右键双击</td>
</tr>
<tr>
<td>WM_MOUSEWHEEL</td>
<td>鼠标滚轮消息</td>
</tr>
</tbody></table>
<p>注：鼠标消息携带的参数：</p>
<ul>
<li><code>WMPARAM</code> ：其他按键的状态， 例如CtrI/Shift等。</li>
<li><code>LPARAM</code> ：鼠标的位置，窗口客户区的坐标系。<ul>
<li><code>LOWORD(LPARAM)</code> ：X坐标位置</li>
<li><code>HIWORD(LPARAM)</code> ：Y坐标位置</li>
</ul>
</li>
</ul>
<p><code>HIWORD</code> 宏-一般用来取得 <code>LPARAM</code> 的高位（高16位），<code>LOWORD</code> 返回值是指定值的低16位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HIWORD(I)	((WORD(((DWORD)(I)&gt;&gt; 16)&amp; 0xFFFF))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOWORD(I)	((WORD)((DWORD_PTR)(I)) &amp; 0xFFFF))</span></span><br></pre></td></tr></table></figure>



<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p><strong>键盘相关消息</strong></p>
<table>
<thead>
<tr>
<th>消息类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>WM_SYSKEYDOWN</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_SYSKEYUP</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_SYSCHAR</td>
<td>系统按键消息，与 <code>ALT</code> 键相组合的组合键</td>
</tr>
<tr>
<td>WM_KEYDOWN</td>
<td>非系统按键消息，键盘按下</td>
</tr>
<tr>
<td>WM_KEYUP</td>
<td>非系统按键消息，键盘弹起</td>
</tr>
<tr>
<td>WM_CHAR</td>
<td>非系统按键消息，键盘字符消息</td>
</tr>
</tbody></table>
<p>需要注意的是：</p>
<ul>
<li>除 <code>Print</code> 键之外都有按下消息</li>
<li>所有键都存在弹起消息</li>
<li>产生字符消息的按键：任何字符键、回退键( <code>BACKSPACE</code>)、回车键、<code>ESC</code>、<code>SHIFT+ENTER</code> (linefeed 换行)、<code>TAB</code></li>
</ul>
<p>键盘驱动程序为每个实体键对应都有一个统一的虚拟键，Windows定义的虚拟键都定义在 <code>WinUser.h</code> 头文件中，都是以 <code>VK</code> 作为前缀。如：回车键的虚拟键是 <code>VK_RETURN</code> ， 数字键是 <code>VK_0 - VK_9</code>。</p>
<p><em><strong>我们是怎么收到 <code>WM_CHAR</code> 的呢?</strong></em></p>
<p>就是因为我们在消息循环时调用了 <code>TranslateMessage</code> 函数对键盘消息进行翻译，如果消息为 <code>WM_KEYDOWN</code> 或者 <code>WM_ SYSKEYDOWN</code> ，并且按键与位移状态相组合产生一个字符， 则 <code>TranslateMessage</code> 把字符消息放入消息队列中。此字符消息将是 <code>GetMessage</code> 从消息队列中得到的按键消息之后的下一个消息。</p>
<p>在我们处理这个消息时，对应的 <code>wParam</code> 不是虚拟键，而是 <code>ANSI</code> 或 <code>Unicode</code> 字符代码。一般情况下我们可以这样用： <code>(TCHAR)wParam</code> 。 因为 <code>TranslateMessage</code> 函数从 <code>WM_KEYDOWN</code> 和 <code>WM_SYSKEYDOWN</code> 消息产生了字符消息，所以字符消息是夹在按键<br>消息之间传递给窗口消息处理程序的。</p>
<p>例如，如果 <code>CapsLock</code> 未打开，而使用者按下再释放 <code>A</code> 键，则窗口消息处理程序按顺序将收到如下的三个消息:</p>
<img src="/win32/Win32%20GUI/image-20210207124251700.png" alt="image-20210207124251700" style="zoom: 67%;" align="left">



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wm_keydown: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wm_keyup: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> WM_CHAR:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;char: %x %c\n&quot;</span>, wParam, wParam);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207130743862.png" alt="image-20210207130743862" style="zoom:80%;" align="left">



<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p><code>Windows</code> 应用程序中，图标、菜单、位图、工具条、对话框等是以资源的形式存在的。在 <code>win32</code> 编程中，为方便项目中的资源统一管理， 提供了一个格式统一的资源文件，对各种资源进行管理。资源文件的扩展名是 <code>.rc</code> ，它必须有 <code>resource.h</code> 的头文件来辅助，在程序编译时它会被资源编译器（<code>re.exe</code>）编译生成一个 <code>.res</code> 的二进制文件。</p>
<p>在资源文件中，所有的资源都有一个资源 <code>ID</code> ，实际上是一个常数，用于标识资源文件，其定义在 <code>resourse.h</code> 文件头中。</p>
<h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p>我们可以在【资源视图】中创建资源文件，如下图所示：</p>
<img src="/win32/Win32%20GUI/image-20210207154934554.png" alt="image-20210207154934554" style="zoom:80%;" align="left">



<p>在创建完资源文件后，可以看到，文件中产生了 <code>resourse.h</code> 头文件和 <code>.rc</code> 文件。</p>
<img src="/win32/Win32%20GUI/image-20210207155316435.png" alt="image-20210207155316435" style="zoom:80%;" align="left">



<p>在创建了一个对话框后，发现 <code>resourse.h</code> 文件中出现了资源对应的 <code>ID</code> ，程序编译后生成了 <code>.res</code> 文件。</p>
<img src="/win32/Win32%20GUI/image-20210207155900652.png" alt="image-20210207155900652" style="zoom:80%;" align="left">



<img src="/win32/Win32%20GUI/image-20210207155944034.png" alt="image-20210207155944034" style="zoom:80%;" align="left">



<img src="/win32/Win32%20GUI/image-20210207160328113.png" alt="image-20210207160328113" style="zoom:80%;" align="left">



<h3 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h3><p><code>Windows</code> 提供了相应的 <code>API</code> 加载图标、菜单、位图、工具条、字符串等资源。</p>
<p><strong>常用API</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadImage</td>
<td>加载图像资源（可加载位图、游标、图标）</td>
</tr>
<tr>
<td>LoadBitmap</td>
<td>加载指定的位图资源</td>
</tr>
<tr>
<td>Loadlcon</td>
<td>加载指定的图标资源</td>
</tr>
<tr>
<td>LoadCursor</td>
<td>加载指定的游标资源</td>
</tr>
<tr>
<td>LoadString</td>
<td>加载字符串资源</td>
</tr>
<tr>
<td>LoadMenu</td>
<td>加载指定的菜单资源</td>
</tr>
<tr>
<td>LoadAccelerators</td>
<td>加载指定的加速器表（快捷键）</td>
</tr>
</tbody></table>
<p>注：当使用的资源是系统资源时, <code>hInstance</code>  必须为 <code>NULL </code> 。</p>
<h2 style="color:pink">自定义进程图标</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE g_hInstance;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,		<span class="comment">//进程内存地址, 实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hPrevInstance,	<span class="comment">//NULL，不同用管</span></span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR     lpCmdLine,		<span class="comment">//命令行</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span>       nCmdShow)</span>			<span class="comment">//显示样式</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//进程内存地址</span></span><br><span class="line">	g_hInstance = hInstance;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.定义窗口</span></span><br><span class="line">	TCHAR classname[] = TEXT(<span class="string">&quot;MFC Window&quot;</span>);</span><br><span class="line">	WNDCLASS wndclass = &#123; <span class="number">0</span> &#125;;	<span class="comment">//初始化</span></span><br><span class="line">	wndclass.hbrBackground = (HBRUSH)COLOR_BACKGROUND;</span><br><span class="line">	wndclass.lpszClassName = classname;</span><br><span class="line">	wndclass.hInstance = hInstance;</span><br><span class="line">	wndclass.lpfnWndProc = WindowProc;</span><br><span class="line">	wndclass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));	<span class="comment">// 自定义图标</span></span><br><span class="line">	RegisterClass(&amp;wndclass);	<span class="comment">//注册窗口类</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207172356318.png" alt="image-20210207172356318" style="zoom:80%;" align="left">





<h2 style="color:pink">自定义进程游标</h2>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载系统光标</span></span><br><span class="line"><span class="comment">// wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);</span></span><br><span class="line"><span class="comment">// 加载自定义光标</span></span><br><span class="line">wndclass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_WAIT);</span><br></pre></td></tr></table></figure>





<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮既是 <code>Windows</code> 的标准控件，也是子窗口，窗口类名是 <code>button</code> 。因为按钮是子窗口，因此按键应是在窗口创建初始化的 <code>WM_CREATE</code> 消息中创建，其 <code>Style</code> 属性值应包含 <code>WS_CHILD | WS_VISABLE</code> 。</p>
<h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create...\n&quot;</span>);</span><br><span class="line">    LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;</span><br><span class="line">    <span class="comment">// 普通按钮</span></span><br><span class="line">    HWND hButton = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;普通按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <span class="number">30</span>, <span class="number">30</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd,(HMENU)<span class="number">1000</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 单选按钮</span></span><br><span class="line">    HWND hButton1 = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;单选按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_AUTORADIOBUTTON, <span class="number">30</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">1001</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 复选按钮</span></span><br><span class="line">    HWND hButton2 = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;复选按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, <span class="number">30</span>, <span class="number">120</span>, <span class="number">80</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">1002</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207142037881.png" alt="image-20210207142037881" style="zoom:67%;" align="left">



<h4 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h4><p>按钮控件会向父窗口发送 <code>WM_COMMAND</code> 消息。</p>
<ul>
<li><code>BN_CLICKED</code> ：用户在按钮上单击鼠标时会向父窗口发送 <code>BN_CLICKED </code> 消息。</li>
<li><code>BN_DOUBLECLICKED</code> ：双击按钮时，会向父窗口发送 <code>BN_DOUBLECLICKED</code> 消息。</li>
</ul>
<p><code>LOWORD(wParam)</code> 是控件 <code>ID</code> ，<code>HIWORD(wParam)</code> 是 <code>notification code</code> 。比如 <code>BN_CLICKED</code> ，<code>BN_DBLCLK</code> 等，标志用户对控件的操作，双击、单击等。<code>lParam</code> 是控件句柄。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">1000</span> &amp;&amp; HIWORD(wParam) == BN_CLICKED)</span><br><span class="line">    &#123;</span><br><span class="line">    	MessageBox(hwnd,<span class="string">L&quot;按钮被单击！&quot;</span>,<span class="string">L&quot;提示&quot;</span>,MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207144326809.png" alt="image-20210207144326809" style="zoom:67%;" align="left">



<h4 id="获取状态"><a href="#获取状态" class="headerlink" title="获取状态"></a>获取状态</h4><p>想要获取单选按钮或复选框的选中状态，可以直接使用 <code>BM_GETCHECK</code> 宏，或者使用 <code>SendMessage</code> 向控件发送 <code>BM_GETCHECK</code> 消息，其返回值为：</p>
<img src="/win32/Win32%20GUI/image-20210207144946115.png" alt="image-20210207144946115" style="zoom: 80%;" align="left">



<h2 style="color:pink">使用SendMessage函数获取</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">1002</span> &amp;&amp; HIWORD(wParam) == BN_CLICKED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (BST_CHECKED == SendMessage(lParam,BM_GETCHECK,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            MessageBox(hwnd, <span class="string">L&quot;复选框被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MessageBox(hwnd, <span class="string">L&quot;复选框未被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210207150305788.png" alt="image-20210207150305788" style="zoom:80%;" align="left">





<h2 style="color:pink">使用Button_GetCheck宏获取</h2>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windowsx.h&gt;</span>	<span class="comment">// 使用 Button_GetCheck 宏需要引入 windowsx.h 头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	该宏的定义, 其本质还是调用 SendMessage 函数</span></span><br><span class="line"><span class="comment">#define Button_GetCheck(hwndCtl)            ((int)(DWORD)SNDMSG((hwndCtl), BM_GETCHECK, 0L, 0L))</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BST_CHECKED == Button_GetCheck(lParam))</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;复选框被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;复选框未被选中！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="美化按钮"><a href="#美化按钮" class="headerlink" title="美化按钮"></a>美化按钮</h4><p><code>Windows</code> 自带的按钮比较朴素，我们可以使用 <code>BS_BITMAP</code> 在按钮上将显示位图,而达到美化按钮的目的！在创建位图按钮时，其 <code>Style</code> 属性值应为 <code>BS_BITMAP</code>。我们可以使用 <code>Loadlmage</code> 函数加载图标、光标、动画光标或位图。使用 <code>SendMessage</code> 函数将图标资源与按钮相绑定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;create...\n&quot;</span>);</span><br><span class="line">    LPCREATESTRUCT pCreateStruct = (LPCREATESTRUCT)lParam;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通按钮</span></span><br><span class="line">    HWND hButton = CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;普通按钮&quot;</span>, WS_CHILD | WS_VISIBLE | BS_BITMAP, <span class="number">30</span>, <span class="number">30</span>, <span class="number">800</span>, <span class="number">300</span>, hwnd,(HMENU)<span class="number">1000</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">    HBITMAP hBmp = LoadBitmap(pCreateStruct-&gt;hInstance, MAKEINTRESOURCE(IDB_BITMAP_haha));</span><br><span class="line">    <span class="comment">//HBITMAP hBmp = (HBITMAP)LoadImage(NULL,L&quot;C:\\Users\\最美的平凡\\Desktop\\haha.bmp&quot;, IMAGE_BITMAP,0,0, LR_LOADFROMFILE);</span></span><br><span class="line">    LRESULT  ret = SendMessage(hButton, BM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hBmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hBmp is %p, ret is %p\n&quot;</span>, hBmp, ret);</span><br><span class="line">    SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/win32/Win32%20GUI/image-20210207170529343.png" alt="image-20210207170529343"></p>
<h3 id="静态文本"><a href="#静态文本" class="headerlink" title="静态文本"></a>静态文本</h3><p>静态文本控件主要用来显示文本信息，不接受用户输入，一般不需处理消息。静态文本框既是标准的 <code>Windows</code> 控件，也是子窗口，其窗口类名为 <code>static</code> 。</p>
<p>一个静态控件用来显示一个文本字符串、框、矩形、图标、光标、位图或增强的图元文件。它可以被用来作为标签、框或用来分隔其它的控件。一个静态控件不接收输入，也不提供输出；但是，如果它是用 <code>SS_NOTIFY</code> 风格创建的，则它可以通知其父窗口点击的消息。</p>
<h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><p>可使用 <code>SetWindowText</code> 函数修改静态文本框的内容。</p>
<p>如果目标窗口由当前进程拥有，则 <code>SetWindowText</code> 将导致 <code>WM_SETTEXT</code> 消息发送到指定的窗口或控件。如果控件是使用<br><code>WS_CAPTION</code> 样式创建的列表框控件，<code>SetWindowText</code> 将设置控件的文本，而不是列表框条目。要在另一个进程中设置控件<br>的文本，应直接发送 <code>WM_SETTEXT</code> 消息，而不是调用 <code>SetWindowText</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态文本控件</span></span><br><span class="line">HWND hStatic = CreateWindow(<span class="string">L&quot;Static&quot;</span>, <span class="string">L&quot;这是一个静态文本&quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER | SS_BITMAP | SS_NOTIFY,<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">30</span>, hwnd, (HMENU)<span class="number">111</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//设置控件（子窗口）内容</span></span><br><span class="line">SetWindowText(hStatic, <span class="string">L&quot;更改后的内容！&quot;</span>);</span><br><span class="line"><span class="comment">//加载位图</span></span><br><span class="line">HBITMAP hBmp = LoadBitmap(pCreateStruct-&gt;hInstance, MAKEINTRESOURCE(IDB_BITMAP_Button));</span><br><span class="line"><span class="comment">//向控件发送STM_SETIMAGE消息设置静态控件的位图</span></span><br><span class="line">SendMessage(hStatic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBmp);</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208125813842.png" alt="image-20210208125813842" style="zoom:67%;" align="left">



<img src="/win32/Win32%20GUI/image-20210208125218931.png" alt="image-20210208125218931" style="zoom:80%;" align="left">



<h4 id="消息处理-1"><a href="#消息处理-1" class="headerlink" title="消息处理"></a>消息处理</h4><p>我们可以设置静态文本框的属性包含 <code>SS_NOTIFY</code> ，这样，文本框便具有了消息处理能力。（可对于点击、双击具有响应能力）</p>
<p>静态文本控件会向父窗口发送 <code>WM_COMMAND</code> 消息。</p>
<ul>
<li><code>STN_CLICKED</code> ：用户在文本框上单击鼠标时会向父窗口发送 <code>BN_CLICKED </code> 消息。</li>
<li><code>STN_DOUBLECLICKED</code> ：双击文本框时，会向父窗口发送 <code>BN_DOUBLECLICKED</code> 消息。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (LOWORD(wParam) == <span class="number">111</span> &amp;&amp; HIWORD(wParam) == STN_CLICKED) &#123;</span><br><span class="line">        MessageBox(hwnd, <span class="string">L&quot;静态文本框被点击！&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208131909438.png" alt="image-20210208131909438" style="zoom: 80%;" align="left">



<h4 id="美化控件"><a href="#美化控件" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->





<h3 id="编辑框"><a href="#编辑框" class="headerlink" title="编辑框"></a>编辑框</h3><p>编辑框控件是一个子窗口矩形，用户可以向其中输入单行、多行或密码文本。编辑框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>edit</code> 。</p>
<h4 id="创建-4"><a href="#创建-4" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建编辑框控件</span></span><br><span class="line">HWND hEdit = CreateWindow(<span class="string">L&quot;edit&quot;</span>, <span class="string">L&quot;这是一个编辑框&quot;</span>, WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_MULTILINE | ES_AUTOVSCROLL | ES_NOHIDESEL,<span class="number">100</span>, <span class="number">300</span>, <span class="number">200</span>, <span class="number">100</span>, hwnd, (HMENU)<span class="number">112</span>, pCreateStruct-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// WM_COMMEND 消息处理函数</span></span><br><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">112</span> &amp;&amp; HIWORD(wParam) == EN_CHANGE) &#123;</span><br><span class="line">    MessageBox(hwnd, <span class="string">L&quot;编辑框被修改！\n&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208143208786.png" alt="image-20210208143208786" style="zoom:67%;" align="left">



<h4 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h4><p><strong>编辑框实现 <code>ENTER</code> 换行和滚动条</strong></p>
<ul>
<li>想要返回：<code>TRUE</code></li>
<li>多行：<code>TRUE</code></li>
<li><code>Auto HScroll</code> ：<code>False</code></li>
</ul>
<p><strong>编辑框文本追加</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TCHAR lpszText[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;	</span><br><span class="line"><span class="comment">/* 以下两条语句为在edit中追加字符串 */</span></span><br><span class="line">SendMessage(hEdit, EM_SETSEL, <span class="number">-2</span>, <span class="number">-1</span>);</span><br><span class="line">SendMessage(hEdit, EM_REPLACESEL, TRUE, lpszText);</span><br><span class="line"><span class="comment">/* 设置滚轮到末尾，这样就可以看到最新信息 (好像没什么用~)*/</span></span><br><span class="line">SendMessage(hEdit, WM_VSCROLL, SB_BOTTOM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>





<h4 id="消息处理-2"><a href="#消息处理-2" class="headerlink" title="消息处理"></a>消息处理</h4><p>我们可以使用 <code>GetWindowText</code> 函数获取到编辑框的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">112</span> &amp;&amp; HIWORD(wParam) == EN_CHANGE) &#123;</span><br><span class="line">    TCHAR buff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    GetWindowText(lParam, buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">    <span class="comment">//MessageBox(hwnd, L&quot;编辑框被修改！\n&quot;, L&quot;提示&quot;, MB_OK);</span></span><br><span class="line">    wprintf(<span class="string">L&quot;buff: %s\n&quot;</span>, buff);</span><br><span class="line">    MessageBox(hwnd, buff, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208144725003.png" alt="image-20210208144725003" style="zoom:80%;" align="left">



<h4 id="美化控件-1"><a href="#美化控件-1" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->



<h3 id="列表框"><a href="#列表框" class="headerlink" title="列表框"></a>列表框</h3><p>列表框就是提供选项列表给用户选择，在多选列表框里，还可选择许多项。列表框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>ListBox</code> 。</p>
<h4 id="创建-5"><a href="#创建-5" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建列表框控件</span></span><br><span class="line">HWND   hListBox = CreateWindow(<span class="string">L&quot;listbox&quot;</span>, <span class="string">L&quot;XXX&quot;</span>, WS_CHILD | WS_VISIBLE | LBS_SORT | LBS_NOTIFY, <span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>, hwnd, (HMENU)<span class="number">113</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//向末尾添加选项</span></span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;B音乐&quot;</span>);</span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;A啤酒&quot;</span>);</span><br><span class="line">SendMessage(hListBox, LB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;C啤酒&quot;</span>);</span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line">SendMessage(hListBox, LB_INSERTSTRING, <span class="number">1</span>, (LPARAM)<span class="string">L&quot;炸鸡&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择其中一项,选择索引为2的，单选模式才有效</span></span><br><span class="line">SendMessage(hListBox, LB_SETCURSEL, <span class="number">2</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208150016180.png" alt="image-20210208150016180" style="zoom:67%;" align="left">



<h4 id="消息处理-3"><a href="#消息处理-3" class="headerlink" title="消息处理"></a>消息处理</h4><p>列表框属性需要包含 <code>LBS_NOTIFY</code> 属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (LOWORD(wParam) == <span class="number">113</span> &amp;&amp; HIWORD(wParam) == LBN_SELCHANGE) &#123;</span><br><span class="line">    <span class="comment">// 获取当前选择的索引</span></span><br><span class="line">    UINT index = SendMessage(lParam, LB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取索引对应的字符串 </span></span><br><span class="line">    TCHAR  buff[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SendMessage(lParam, LB_GETTEXT, index, (LPARAM)buff);</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, buff, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208150831772.png" alt="image-20210208150831772" style="zoom:67%;" align="left">



<h4 id="美化控件-2"><a href="#美化控件-2" class="headerlink" title="美化控件"></a>美化控件</h4><!-- 略 -->



<h3 id="组合框"><a href="#组合框" class="headerlink" title="组合框"></a>组合框</h3><p><code>Windows</code> 组合框由一个列表框和一个（静态文本或编辑控件）组合。列表框可以一直显示的，也可以隐藏，在用户单击控件右上角的下拉箭头时下拉出该列表框，列表框中当前选中的项（如果有的话）显示在静态控件或编辑控件中。组合框控件既是 <code>Windows</code> 标准控件，也是子窗口，它的窗口类名是 <code>ComboBox</code> 。</p>
<h4 id="创建-6"><a href="#创建-6" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">	&#123;</span><br><span class="line">		LPCREATESTRUCT   pcs = (LPCREATESTRUCT)lParam;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建组合框</span></span><br><span class="line">		HWND   hComboBox=CreateWindow(<span class="string">L&quot;comboBOX&quot;</span>, <span class="string">L&quot;XXX&quot;</span>, WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST|CBS_SORT,</span><br><span class="line">			<span class="number">30</span>, <span class="number">30</span>, <span class="number">200</span>, <span class="number">100</span>, hWnd, (HMENU)<span class="number">111</span>, pcs-&gt;hInstance, <span class="literal">NULL</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向组合框添加选项 </span></span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;C音乐&quot;</span>);</span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;A啤酒&quot;</span>);</span><br><span class="line">		SendMessage(hComboBox, CB_ADDSTRING, <span class="number">0</span>, (LPARAM)<span class="string">L&quot;B炸鸡&quot;</span>);</span><br><span class="line">		<span class="comment">//插入选项</span></span><br><span class="line">		SendMessage(hComboBox, CB_INSERTSTRING, <span class="number">2</span>, (LPARAM)<span class="string">L&quot;编程&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//选择某一项</span></span><br><span class="line">		SendMessage(hComboBox, CB_SETCURSEL, <span class="number">3</span>,  <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span>   WM_COMMAND:</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		WORD  id = LOWORD(wParam);<span class="comment">//控件ID</span></span><br><span class="line">		WORD  code = HIWORD(wParam);<span class="comment">//消息类型</span></span><br><span class="line">		HWND   hCtrl = (HWND)lParam;<span class="comment">//窗口句柄</span></span><br><span class="line"></span><br><span class="line">		 <span class="comment">//父窗口接收到子控件发的消息</span></span><br><span class="line">		<span class="keyword">if</span> (id == <span class="number">111</span> &amp;&amp; code ==CBN_SELCHANGE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//获取当前选择的索引</span></span><br><span class="line">			<span class="keyword">int</span>   index=SendMessage(hCtrl, CB_GETCURSEL, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//获取索引对应的文本</span></span><br><span class="line">			TCHAR  buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			SendMessage(hCtrl, CB_GETLBTEXT, index, (LPARAM)buf);</span><br><span class="line">			MessageBox(hWnd, buf, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>







<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>列表控件是一个显示项目集合的控件，是 <code>Windows</code> 中的通用控件，其包含在 <code>Comctrl32.dll</code> 。<code>Windows</code> 中的通用控件在程序编译时并不会默认编译入程序，而标准控件不默认编译入程序，需要手动包含。</strong></p>
<p>列表控件在创建后，需要引入以下声明才可以使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;commctrl.h&gt;</span>			</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;comctl32.lib&quot;</span>)			</span></span><br></pre></td></tr></table></figure>





<p><del>通用控件在使用前，需要通过 <code>INITCOMMONCONTROLSEX</code> 进行初始化。</del><br><del>只要在程序中的任意地方引用了该函数就会使得 Windows 的程序加载器加载该库。</del>                </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INITCOMMONCONTROLSEX icex;				</span><br><span class="line">icex.dwSize = <span class="keyword">sizeof</span>(INITCOMMONCONTROLSEX);				</span><br><span class="line">icex.dwICC = ICC_WIN95_CLASSES;				</span><br><span class="line">InitCommonControlsEx(&amp;icex);	</span><br></pre></td></tr></table></figure>



<p>列表控件提供了4种排列和显示项目的方法，其类名是 <code>WC_LISTVIEW</code> 。该控件会向父窗口发送 <code>WM_ NOTIFY</code> 消息的形式的通知代码。</p>
<img src="/win32/Win32%20GUI/image-20210208182450925.png" alt="image-20210208182450925" style="zoom:80%;" align="left">



<h4 id="LVS-ICON"><a href="#LVS-ICON" class="headerlink" title="LVS_ICON"></a>LVS_ICON</h4><p>图像列表（<code>Image Lists</code>）是相同大小图像的一个集合，以0为图像的起始索引，它本身并不是控件，但和 <code>List View</code> 、<code>Tree View</code> 等控件一起使用。</p>
<p>ImageList Create</p>
<h4 id="LVS-REPORT"><a href="#LVS-REPORT" class="headerlink" title="LVS_REPORT"></a>LVS_REPORT</h4><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>对话框分为模态对话框和非模态对话框两类。</p>
<ul>
<li>模态对话框（ <code>modal</code>）：是指在用户想要对对话框以外的应用程序进行操作时，必须首先对该对话框进行响应，如单击【确定】或【取消】按钮等将该对话框关闭，否则无法操作父窗口。</li>
<li>非模态对话框（<code>modeless</code>）：指对话框显示后，程序其他窗口仍能正常运行，可以响应用户输入，还可以相互切换。</li>
</ul>
<p><img src="/win32/Win32%20GUI/image-20210208153317296.png" alt="image-20210208153317296"></p>
<h4 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h4><p><code>MessageBox</code> 是一个模态对话框，可以通过定制 <code>MssageBox</code> 以实现不同的需求。</p>
<img src="/win32/Win32%20GUI/image-20210208160648494.png" alt="image-20210208160648494" style="zoom:67%;" align="left">



<h4 id="创建（模态）"><a href="#创建（模态）" class="headerlink" title="创建（模态）"></a>创建（模态）</h4><p><code>DialogBox</code> 宏从对话框资源模板中创建模态对话框,，<code>DialogBox</code> 宏实际使用了 <code>DialogBoxParam</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DialogBox</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,	<span class="comment">//应用程序实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpTemplate,	<span class="comment">// 对话框模板，使用MAKEINTRESOURCE宏创建此值。</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,	<span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpDialogFunc	<span class="comment">//指向对话框过程的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="回调函数-1"><a href="#回调函数-1" class="headerlink" title="回调函数"></a>回调函数</h4><p>由 <code>CreateDialog</code> 和 <code>DialogBox</code> 函数系列使用的应用程序定义的回调函数。它处理发送到模式对话框或无模式对话框的消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DLGPROC Dlgproc;</span><br><span class="line"></span><br><span class="line"><span class="function">INT_PTR <span class="title">Dlgproc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HWND hwndDlg,		<span class="comment">//对话框窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  UINT uMsg,		<span class="comment">//消息</span></span></span></span><br><span class="line"><span class="params"><span class="function">  WPARAM wParam,	<span class="comment">//消息附加参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPARAM lParam		<span class="comment">//消息附加参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>注：通常，如果对话框过程处理了消息，则应返回 <code>TRUE</code> ，否则应返回 <code>FALSE</code> 。如果对话框过程返回 <code>FALSE</code> ，则对话框管理器将响应该消息执行默认对话框操作。</p>
<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对话框</span></span><br><span class="line">DialogBox(GetModuleHandle(<span class="literal">NULL</span>), IDD_DIALOG_main, hwnd, DialogProc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208163329040.png" alt="image-20210208163329040" style="zoom:67%;" align="left">



<h4 id="消息处理-4"><a href="#消息处理-4" class="headerlink" title="消息处理"></a>消息处理</h4><h5 id="WM-INITDIALOG"><a href="#WM-INITDIALOG" class="headerlink" title="WM_INITDIALOG"></a>WM_INITDIALOG</h5><p>在对话框显示之前立即发送到对话框过程，对话框程序通常使用此消息来初始化控件并执行任何影响对话框外观的其他初始化任务。</p>
<h5 id="WM-CTLCOLORDLG"><a href="#WM-CTLCOLORDLG" class="headerlink" title="WM_CTLCOLORDLG"></a>WM_CTLCOLORDLG</h5><p>在系统绘制对话框之前发送到对话框。通过响应此消息，对话框可以使用指定的显示设备上下文句柄来设置其文本和背景颜色。</p>
<p>wParam中对话框的设备上下文句柄。<br>IParam的对话框的句柄。<br>如果应用程序处理此消息，则它必须返回画笔句柄，系统使用画笔绘制对话框的背景。系统不会自动<br>销毁返回的画笔，当刷子不再需要时，应用程序有责任销毁刷子。<br>请注意WM CTLCOLORDLG消息发送到对话框本身;所有其他WM CTLCOLOR *消息都发送给控件<br>的所有者。</p>
<h5 id="EndDialog"><a href="#EndDialog" class="headerlink" title="EndDialog"></a>EndDialog</h5><p><code>EndDialog</code> 函数用于销毁模态对话框，使系统结束对话框的任何处理。</p>
<p><code>EndDialog</code> 不会立即销毁对话框，它会设置一个标志， 对话框过程在尝试从应用程序队列中检索下一条消息之前,系统检查标志。如果标志被设置，系统结束消息循环，销毁对话框，并使用 <code>nResult</code> 中的值作为创建对话框的函数的返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get message...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msg: %p %p\n&quot;</span>, wParam, lParam);</span><br><span class="line">    EndDialog(hwnd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>无论点击任何按钮，其产生的消息都是 <code>0x02</code> ，即 <code>WM_DESTROY</code> 消息。其本质是由于 <code>Dialog</code> 是一个对话框，执行任何操作都将会销毁对话框，且 <code>Dialog</code> 创建函数将会接收到一个返回值，这与 <code>MessageBox</code> 的特性无异。</p>
<img src="/win32/Win32%20GUI/image-20210208170324650.png" alt="image-20210208170324650" style="zoom:80%;" align="left">



<h4 id="创建（非模态）"><a href="#创建（非模态）" class="headerlink" title="创建（非模态）"></a>创建（非模态）</h4><p>非模态对话框可以使用 <code>CreateDialog</code> 函数创建，默认发送 <code>WM_INITDIALOG</code> 消息到对话框过程（回调函数），应手动 <code>ShowWindow</code> 函数显示对话框，使用 <code>DestroyWindow</code> 函数销毁对话框。非模态对话框的本质就是创建窗口，销毁使用 <code>DestroyWindows</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">CreateDialog</span><span class="params">(	<span class="comment">// 返回非模态对话框的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hInstance,		<span class="comment">// 当前程序实例句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpName,			<span class="comment">// 模板名</span></span></span></span><br><span class="line"><span class="params"><span class="function">   hWndParent,		<span class="comment">// 父窗口句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">   lpDialogFunc		<span class="comment">// 回调函数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<p>测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建非模态对话框</span></span><br><span class="line">HWND hDialog = CreateDialog(GetModuleHandle(<span class="literal">NULL</span>), IDD_DIALOG_main, hwnd, DialogProc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd,</span></span></span><br><span class="line"><span class="params"><span class="function">	UINT uMsg,</span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (uMsg) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Dialog init...\n&quot;</span>);</span><br><span class="line">			ShowWindow(hwnd, SW_SHOW);</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get message...\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;msg: %p %p\n&quot;</span>, wParam, lParam);</span><br><span class="line">			DestroyWindow(hwnd);</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到，在没有对对话框进行操作的情况下依然可以对主窗口进行操作。</p>
<p><img src="/win32/Win32%20GUI/image-20210208172525566.png" alt="image-20210208172525566"></p>
<h4 id="创建主界面（非）"><a href="#创建主界面（非）" class="headerlink" title="创建主界面（非）"></a>创建主界面（非）</h4><p>我们可以使用非模态对话框创建程序主界面，通过可视化的图形界面创建窗口，可以极大的提高开发效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的对话框窗口过程</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DialogProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HWND hwnd, </span></span></span><br><span class="line"><span class="params"><span class="function">	UINT Msg, </span></span></span><br><span class="line"><span class="params"><span class="function">	WPARAM wParam, </span></span></span><br><span class="line"><span class="params"><span class="function">	LPARAM lParam</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (Msg)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WM_INITDIALOG:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//设置对话框标题</span></span><br><span class="line">			SetWindowText(hwnd, <span class="string">L&quot;LoadPE by walker&quot;</span>);</span><br><span class="line">			<span class="comment">//设置对话框图标</span></span><br><span class="line">			HICON icon = LoadIcon(GetModuleHandle(<span class="literal">NULL</span>), MAKEINTRESOURCE(IDI_ICON_exeico));</span><br><span class="line">			SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)icon);</span><br><span class="line">			DestroyIcon(icon);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> IDCANCEL:</span><br><span class="line">				&#123;</span><br><span class="line">					DestroyWindow(hwnd);<span class="comment">//销毁非模态对话框</span></span><br><span class="line">					PostQuitMessage(<span class="number">0</span>);	<span class="comment">//WM_QUIT退出消息循环</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>  FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hInstance, </span></span></span><br><span class="line"><span class="params"><span class="function">	HINSTANCE hPrevInstance,</span></span></span><br><span class="line"><span class="params"><span class="function">	LPSTR lpCmdLine, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> nShowCmd</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建非模态对话框</span></span><br><span class="line">	HWND hDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG_main),GetDesktopWindow(), DialogProc);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示对话框</span></span><br><span class="line">	ShowWindow(hDlg, SW_SHOW);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//消息循环</span></span><br><span class="line">	MSG  msg;</span><br><span class="line">	<span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		TranslateMessage(&amp;msg);</span><br><span class="line">		DispatchMessage(&amp;msg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/win32/Win32%20GUI/image-20210208180425088.png" alt="image-20210208180425088" style="zoom:80%;" align="left">





<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p><code>Windows</code> 程序的菜单，分为三大类：系统菜单、顶层菜单、弹出式菜单（右键菜单）。</p>
<p><img src="/win32/Win32%20GUI/image-20210215142827558.png" alt="image-20210215142827558"></p>
<p><img src="/win32/Win32%20GUI/image-20210215142728919.png" alt="image-20210215142728919"></p>
<h4 id="顶层菜单"><a href="#顶层菜单" class="headerlink" title="顶层菜单"></a>顶层菜单</h4><p>（略）</p>
<h4 id="快捷菜单"><a href="#快捷菜单" class="headerlink" title="快捷菜单"></a>快捷菜单</h4><p>快捷菜单，即弹出菜单、右键菜单。我们可以调用 <code>CreatePopupMenu</code> 函数可以创建一个弹出菜单对象（子菜单），然后响应鼠标右键 <code>WM_ RBUTTONDOWN</code> 消息，使用 <code>TrackPopupMenu</code> 函数可以轻松实现右键菜单属性。</p>
<p>当我们使用函数创建右键菜单后，菜单项是空的，我们可以使用 <code>InsertMenuItem</code> 函数来插入菜单项我们还可以使用 <code>InsertMenu</code> 和 <code>AppendMenu</code> 函数来添加菜单项。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    walker
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://walker-nie.github.io/win32/Win32%20GUI/" title="win32 gui">https://walker-nie.github.io/win32/Win32%20GUI/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/win32/" rel="tag"># win32</a>
          
            <a href="/tags/win32-gui/" rel="tag"># win32 gui</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/win32/Win32/" rel="next" title="win32">
                <i class="fa fa-chevron-left"></i> win32
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic%2Ff6%2Fc9%2Ff6%2Ff6c9f647a533782026c0609ac5d550df.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643531815&t=c2c18e0685888311dca4f731dd286208"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Win32-GUI"><span class="nav-number">1.</span> <span class="nav-text">Win32 GUI</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">字符集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%A3"><span class="nav-number">1.1.3.</span> <span class="nav-text">函数入口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">命令行传参</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">回调函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GUI-API"><span class="nav-number">1.2.</span> <span class="nav-text">GUI API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-W"><span class="nav-number">1.2.1.</span> <span class="nav-text">A&#x2F;W</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8-API"><span class="nav-number">1.2.2.</span> <span class="nav-text">常用 API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">消息处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MSG"><span class="nav-number">1.3.1.</span> <span class="nav-text">MSG</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">消息类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WM-COMMAND"><span class="nav-number">1.3.1.1.1.</span> <span class="nav-text">WM_COMMAND</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#VM-NOTIFY"><span class="nav-number">1.3.1.1.2.</span> <span class="nav-text">VM_NOTIFY</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF"><span class="nav-number">1.3.1.1.3.</span> <span class="nav-text">自定义消息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">消息发送</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SendMessage"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">SendMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PostMessage"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">PostMessage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PostThreadMessage"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">PostThreadMessage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">1.3.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.3.3.</span> <span class="nav-text">消息循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">窗口过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">1.4.</span> <span class="nav-text">窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-NCCREATE"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">WM_NCCREATE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-CREATE"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">WM_CREATE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%AD"><span class="nav-number">1.4.2.</span> <span class="nav-text">关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-CLOSE"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">WM_CLOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-DESTROY"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">WM_DESTROY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-NCDESTROY"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">WM_NCDESTROY</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA"><span class="nav-number">1.4.3.</span> <span class="nav-text">显示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-PAINT"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">WM_PAINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-NCPAINT"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">WM_NCPAINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WM-ERASEBKGND"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">WM_ERASEBKGND</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87"><span class="nav-number">1.4.4.</span> <span class="nav-text">鼠标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E7%9B%98"><span class="nav-number">1.4.5.</span> <span class="nav-text">键盘</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">1.5.</span> <span class="nav-text">资源文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.2.</span> <span class="nav-text">加载资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.6.</span> <span class="nav-text">自定义进程图标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.7.</span> <span class="nav-text">自定义进程游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%92%AE"><span class="nav-number">1.7.1.</span> <span class="nav-text">按钮</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-2"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">消息处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%8A%B6%E6%80%81"><span class="nav-number">1.7.1.3.</span> <span class="nav-text">获取状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.8.</span> <span class="nav-text">使用SendMessage函数获取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">1.9.</span> <span class="nav-text">使用Button_GetCheck宏获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%8E%E5%8C%96%E6%8C%89%E9%92%AE"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">美化按钮</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%87%E6%9C%AC"><span class="nav-number">1.9.1.</span> <span class="nav-text">静态文本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-3"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86-1"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">消息处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%8E%E5%8C%96%E6%8E%A7%E4%BB%B6"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">美化控件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%E6%A1%86"><span class="nav-number">1.9.2.</span> <span class="nav-text">编辑框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-4"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">文本编辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86-2"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">消息处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%8E%E5%8C%96%E6%8E%A7%E4%BB%B6-1"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">美化控件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%A1%86"><span class="nav-number">1.9.3.</span> <span class="nav-text">列表框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-5"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86-3"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">消息处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BE%8E%E5%8C%96%E6%8E%A7%E4%BB%B6-2"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">美化控件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A1%86"><span class="nav-number">1.9.4.</span> <span class="nav-text">组合框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-6"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">创建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8"><span class="nav-number">1.9.5.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS-ICON"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">LVS_ICON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LVS-REPORT"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">LVS_REPORT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-number">1.9.6.</span> <span class="nav-text">对话框</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MessageBox"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">MessageBox</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%88%E6%A8%A1%E6%80%81%EF%BC%89"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">创建（模态）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86-4"><span class="nav-number">1.9.6.4.</span> <span class="nav-text">消息处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WM-INITDIALOG"><span class="nav-number">1.9.6.4.1.</span> <span class="nav-text">WM_INITDIALOG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WM-CTLCOLORDLG"><span class="nav-number">1.9.6.4.2.</span> <span class="nav-text">WM_CTLCOLORDLG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EndDialog"><span class="nav-number">1.9.6.4.3.</span> <span class="nav-text">EndDialog</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%EF%BC%88%E9%9D%9E%E6%A8%A1%E6%80%81%EF%BC%89"><span class="nav-number">1.9.6.5.</span> <span class="nav-text">创建（非模态）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%BB%E7%95%8C%E9%9D%A2%EF%BC%88%E9%9D%9E%EF%BC%89"><span class="nav-number">1.9.6.6.</span> <span class="nav-text">创建主界面（非）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95"><span class="nav-number">1.9.7.</span> <span class="nav-text">菜单</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E8%8F%9C%E5%8D%95"><span class="nav-number">1.9.7.1.</span> <span class="nav-text">顶层菜单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E6%8D%B7%E8%8F%9C%E5%8D%95"><span class="nav-number">1.9.7.2.</span> <span class="nav-text">快捷菜单</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2021 &mdash; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">walker</span>

  
</div>








  <div class="footer-custom">Hosted by walker</div>


<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/02/2022 13:00:00");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
